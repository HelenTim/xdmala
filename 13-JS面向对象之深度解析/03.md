# 面向对象深度解析（3）

## TPR？

**1）Symbol？**

通过Symbol 可以在全局创建一个独一无二的值（注意，这并不是一个字符串值）

其语法很简单，直接 `Symbol()`即可生成一个值，而如果给它一个参数的话，如 `Symbol('xxx')`，那么这相当于是给这个值起了个叫 `xxx` 标注，当然，这个参数和Symbol出来的值没啥关系哈！

关于它的使用场景：如果我们不关心一个对象的某个属性的键值是多少的话，那么可以用 `Symbol()`来生成一个值，还有就是在class里边，我们要封装一个有私有调调的方法，即他人使用这个类的时候，即new一个对象出来的时候，是无法访问这个方法的，那么我们也可以把该方法Symbol化！

**➹：**[「每日一题」JS 中的 Symbol 是什么？ - 知乎](https://zhuanlan.zhihu.com/p/22652486)

**2）Java 的多态？**

事物在运行过程中存在不同的状态。例子：花木兰替父从军，花木兰在从军的时候暴露的属性和方法是来自于父亲的（向上转型），而在遇到心爱之人之后，花木兰她揭示了自己的真实身份，即此时她暴露的属性和方法才是真正属于她自己的！（向下转型）——花木兰在从军的过程中存在不同的属性和方法！

> 一个疑问：Java编译的时候做了什么？毕竟在涉及到对多态理解的时候，提及到「成员变量：编译看左边(父类),运行看左边(父类)」等等的文字描述！

**➹：**[JAVA的多态用几句话能直观的解释一下吗？ - 程序狗的回答 - 知乎](https://www.zhihu.com/question/30082151/answer/120520568)

**3）关于对面向对象之封装特性的一些误区？**

封装不是包装，与我们封装一个插件是两码事哈！面向对象的封装是指通过封装的过程能够控制类的属性和方法的可访问的方式！（关键点在于 **可访问** ）

总之，封装就是说：一部分的方法属性只能在这一个类里边访问，而其它外部是无法访问的，还有一部分是完全开放的，只要你实例化了这个类，那么都可以访问，还有一部分只能提供给自己的子类（继承了才可以访问）访问，而其它地方是访问不了的！




## ★封装

### ◇概述

- 面向对象里边的「封装」是面向对象语言的一个重要特性

- 封装：通过封装，控制类的属性与方法的可访问方式（信息隐藏大法）

- 关键字：private、public、protected
  - private：只有类的内部可访问
  - public：完成开发访问
  - protected：可供子类访问

> 我们日常使用一个类，那就是根据这个类，new一个实例出来，而这个实例能否访问类的成员属性或方法，得看我们是否用了public等关键字，当然，在JS 里边，一般类的成员属性和方法都是可访问的！

### ◇封装的好处

- 封装4个好处：

  1. 减少程序的耦合（程序与程序之间不会发生冲突）
  2. 自由修改类内部结构（随便修改封装，也可以说是接口里边的实现而不影响调用者，还有随意添加一些成员和方法……）
  3. 对成员准确的控制（提供3种访问权限，用于告知实例是否可访问，以及以什么样的方式访问）
  4. 隐藏隐私信息（如一些支付算法涉及到加密之类的，显然是类内部用的，即private的，如果有一些公共性的，那么就protected，然后继承了才可以用）

总之，针对不同的场景来为成员添加访问权限，而这会保证了程序的安全、以及程序的生态！

不过，很遗憾的是，ES6并咩有支持面向对象的封装特性！

那么是不是无法实现呢？——其实不是这样的，也是可以实现封装的，不过由于JS 代码是在前端的，即我们可以用浏览器来看到这些代码，所以关于封装的实现意义并咩有那么大！

当然，我们开发者还是希望有这个封装特性的，如TypeScript（JS的语法糖）就很香，毕竟它就支持如private、protected、public等关键字，即实现了面向对象的封装特性！

> ES6也可以实现封装，即实现成员私有，那就是用Symbol哈！

### ◇通过代码进一步了解封装

**1）PHP的封装**

People类：

![People类](assets/img/2019-12-04-14-24-05.png)

Student类：

![Student类](assets/img/2019-12-04-14-21-34.png)

测试：

```php
<?php

require_once('classes/student.php');

$xiaoming = new Student('xiaoming',175,70,1001,'Math');

echo $xiaoming -> say();
```

![say方法](assets/img/2019-12-04-14-29-29.png)

> 在公开的方法里边，居然可以访问到类的私有属性或私有方法！

如果你这样：

```php
echo $xiaoming -> sno;
```

那么：

![Student实例访问类的私有属性](assets/img/2019-12-04-14-33-35.png)

同理：

```
echo $xiaoming -> subject;
```

这样，也是无法访问 `subject` 这个成员是属性的！

接下来测试一下People这个类：

```php
<?php

require_once('classes/people.php');

$xiaohong = new People('xiaohong',160,40);

echo $xiaohong -> name
```

结果：

![People的protected之name属性](assets/img/2019-12-04-16-58-25.png)

同理：

```php
echo $xiaohong -> intro() //Fatal error: Uncaught Error: Call to protected method People::intro() from……
echo $xiaohong -> drink() //Fatal error: Uncaught Error: Call to private method People::drink() from……
```

以上就是封装的好处了，我们在定义Student类的时候，只是想让学生说句自我介绍的话，即定义了一个public的 `say`方法，而其它的成员属性和成员方法是不需要用到的，因此我们就有私有化了，而且由于继承了People这个类，那么People旗下的protected化的成员属性和成员方法Student实例都可以用。

总之，我们定义一个类，如果不想让类旗下的某些属性、方法被外界知道，即被实例知道，那么我们就private呗！反之，如果想让大家都知道，那么就public呗！

好了，这就是所谓的面向对象的封装性了，这非常实用，如果学过Java、Python等纯面向对象语言，你就会发现它们的程序都是用一个一个的类垒起来的！而像PHP这样的，它就不是纯面向对象的语言了，毕竟它可以面向对象开发，也可以面向过程开发！

### ◇通过一些旁门左道来让ES6实现类的成员属性、方法私有化

我们在ES6的class特性写代码的时候，都用一个下划线 `_`来标注这个属性是私有的，如 `_xxx`，不过这是我们人为赋予的意义，即希望这个属性、方法不要让外界访问，但实际上这是可以访问的！（类似于此地无银三百两）

因此，我们利用了`Symbol()`这个值来让我们的成员属性、方法私有化，关于`Symbol()`这个值，它表示唯一的值，即在当前页面永远不可能重复的值!

做法：

``` js
const doAjax = Symbol('doAjax')
class HTTP {
  [doAjax](options) {}
}
```

效果：

![实现成员属性、方法的私有化](assets/img/2019-12-04-20-34-32.png)

除了可以让成员方法私有化以外，成员属性也可以私有化！做法一样哈！

## ★多态

- 多态：成员方法的重载和重写
- 强类型面向对象语言才有意义

所谓的重载：在同一个类里边，存在叫同样名字的成员方法，当然参数不一

所谓的重写：父类有个xxx的方法，子类继承了父类，但子类也写了一个叫xxx的方法

对于JS来说，由于是弱类型语言的缘故，多态的意义不大！

JS的多态有点肤浅：

``` js
class People {
  test(){
    return 1
  }
}
class Student extends People {
  test() {
    return 2
  }
}

let xiaoming = new Student()
xiaoming.test() //2

// 如果Student这个类的test方法注释掉了，那么xiaoming.test()的值就是 1了
```

如果JS是有类型的话，那么就会去根据这个xiaoming的类型去判断该执行是People的test，还是Student的test

总之，多态就是方法的重载与重写

> 一个接口（就是方法）它在不同的类里边有不同的表现，即，有不同的程序的体现，有不用的程序的执行，那么这就叫做面向对象里边类的多态了！

小结：

1. 在ES6里边完全掌握面向对象其实就只有继承，像是封装，我们就用 `Symbol()`实现了成员属性和成员方法的私有化！

2. 重载：在一个类里边，搞几个名字一样的成员方法，不过JS 和 PHP是不支持的；重写：就是子类重写父类的方法，JS的重写体现同PHP是一样的！

## ★面向过程和面向对象

### ◇区别

![面向过程和面向对象图示](assets/img/2019-12-04-22-13-00.png)

了解了面向对象的三大特性以后，我们反过来，反观一下面向对象，它相对应的一种开发模式是面向过程。

通过一个经典的例子「把大象装进冰箱」，来理解面向过程和面向对象。

作为一个有着「面向过程」世界观的程序员，那么「把大象装进冰箱」就会这么做：

``` js
// 面向过程：
function 大象装进冰箱() {
  // ……点点表示省略了一大堆程序
  打开冰箱……  //程序体1
  大象装入……  //程序体2
  关闭冰箱……  //程序体3
}
```

我们获取到一个冰箱之后，就会打开冰箱，然后把对象塞进去，最后关闭冰箱。这是一个过程，而且这是一个步骤顺序，已经指定好步骤顺序之后，就会按照这个步骤一步一步地去执行，去写相应的程序

我们按步骤与顺序去执行一个个的行为，而这也就成为了行为的集合了

而有着「面向对象」世界观的程序员则不是这样的，那么他们是怎样的呢？——他们会这样做：

先想想如何把一件事情抽象成一个对象出来，如一个对象有哪些属性和方法，而不是先想我要怎样才能做到，总之，要先想什么样的东西才能够做到「打开冰箱」……

冰箱它是一个类别，同样也是一个对象，那么这个类别它有哪些属性和方法呢？

有开门、放大象、关门这样的方法，还有一个属性「门」

门+3个方法就构成了我们要完成的这个程序的类别

通过把这些方法和这些属性包装到类里边去，然后实例化这个类别，就能实例化出来一个具体冰箱，然后再按照「开门、装大象、关门」这样的顺序去执行程序：

``` js
// 面向对象
class 冰箱 {
  constructor（）{
    this.门 = '冰箱门'
  }
  开门() {……}
  装东西() {……}
  关门() {……}
}

const 冰箱实例 = new 冰箱()
// 以下这3个步骤其实也是面向过程的步骤
// 但是，这是需要先经过面向对象这种包装的方式之后，然后再进行的面向过程
冰箱实例.开门()
冰箱实例.装东西()
冰箱实例.关门()
```

通过以上代码可以了解到：**面向对象是一种基于面向过程的一种编程思想**，换句话说，就是完成这个「把大象装冰箱」这个功能之前，我们要懂得要把这个程序里边一些主体的东西给**抽象出来成为类**，然后这个类通过实例化再成为具体的你在这个程序的执行过程当中的**一个对象**，然后再通过这个对象去执行相应的我们需要完成的整个程序的这样一个**方法**，最后，就完成整个「把大象装冰箱」的功能了！

话又说来，为啥「面向对象是一种基于面向过程的一种编程思想」呢？

因为你抽象了类以后，其里边所有的方法，实际上这些方法的内部，有些时候还是基于面向过程的！如「开门」这个方法，肯定会涉及到「触摸呈现拉着的手势」，然后「用力往身体这个方向拉」，最后「冰箱门打开了」，所以说这其实也是一个过程，但只是说这是我们一个类里边的一个过程，一个过程性的程序哈！

所以，面向对象和面向过程其实并不冲突，即你在写面向对象的时候，也会遇到写面向过程的，那么你在完成一个功能的时候可能是基于一个类去实例化来完成一个面向过程的这么一个程序

因此，大家需要注意的是：**面向对象和面向过程并不是完全分成两条路走的，而是相辅相成的**

### ◇面向对象的意义

回过头去看学习面向对象这种开发思想的时候，老师举了一些People、Student之类的类，但这些类显然离我们的编程要很远很远，因此，老师就写了一个可切换模式的tab（即选项卡或者说是一个插件）

可是面向对象的意义到底是什么呢？

这是数据结构化的问题，为啥这样说呢？

因为我们在写类的时候，其实类里边的属性和方法都是按照类这样的套路来写的

那么类的套路又是什么呢？——实际上就是集中化哈！

你的属性是集中在一起，你的方法也是集中在一起的，而且它们的意义都是成员属性和成员方法

其实做这样一个过程，即你面向对象抽象一个类出来，然后来写成员属性和成员方法，这整个这样的包装过程，实际上就是**数据的结构化过程**

我们日常中理解的数据是这样的：数字「`123`」、字符串「`'123'`」、JSON数据等等

但其实数据不是这样的。

数据是一切的一切，而一切的一切也都是数据

方法是数据吗？——是数据；属性是数据吗？——也是数据；变量是数据吗？——同样也是数据

还有数据类型是数据吗？——同样也是数据

总之，你要记住一切的编程都基于数据，最后都会变成0和1的数据，所以说，实际上，你在进行编程的时候，用面向对象的方式，实际上就是数据的结构化问题

或许，你会疑问「如果不用面向对象，那数据就没有结构化了吗？」

不用面向对象，也能让数据结构化，只是数据结构化的可行性可能变得更低，而且可能更难以管理

简而言之，



## ★总结

- 关于把「大象装进冰箱」这个比喻，为啥要把冰箱当作是个class呢？冰箱它会自己开门呢？——冰箱它不能自动开门，是我们人类打开的，可这人类就类似于我们自己 写了这样一行代码：`new 冰箱().open()`啊！开发者就像是上帝一样，他们在程序世界里边创造着自己所期望的程序哈！(程序=算法+数据结构+代码组织结构)