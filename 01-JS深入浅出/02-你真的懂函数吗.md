---
typora-copy-images-to: img\02
---

# 你真的懂函数吗

## ★课程简介

1. 定义

   1. 匿名函数
   2. 具名函数
   3. 箭头函数

2. 词法作用域（也叫静态作用域）

   ```js
    var global1 = 1
    function fn1(param1){
        var local1 = 'local1'
        var local2 = 'local2')
        function fn2(param2){
            var local2 = 'inner local2'
            console.log(local1)
            console.log(local2)
        }
   
        function fn3(){
            var local2 = 'fn3 local2'
            fn2(local2)
        }
    }
   ```

   深入阅读：

   - [javascript的词法作用域](http://js8.in/2011/08/15/javascript%E7%9A%84%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/)
   - [静态作用域与动态作用域](https://zh.wikipedia.org/wiki/%E4%BD%9C%E7%94%A8%E5%9F%9F#.E9.9D.99.E6.80.81.E4.BD.9C.E7.94.A8.E5.9F.9F.E4.B8.8E.E5.8A.A8.E6.80.81.E4.BD.9C.E7.94.A8.E5.9F.9F)
   - [Abstract Syntax Tree 抽象语法树简介](https://div.io/topic/1994)

3. call stack

   - [普通调用 1+1+1](http://latentflip.com/loupe/?code=ZnVuY3Rpb24gYSgpewogICAgY29uc29sZS5sb2coJ2EnKQogIHJldHVybiAnYScgIAp9CgpmdW5jdGlvbiBiKCl7CiAgICBjb25zb2xlLmxvZygnYicpCiAgICByZXR1cm4gJ2InCn0KCmZ1bmN0aW9uIGMoKXsKICAgIGNvbnNvbGUubG9nKCdjJykKICAgIHJldHVybiAnYycKfQoKYSgpCmIoKQpjKCk%3D!!!)
   - [嵌套调用 1>2>3](http://latentflip.com/loupe/?code=ZnVuY3Rpb24gYSgpewogICAgY29uc29sZS5sb2coJ2ExJykKICAgIGIoKQogICAgY29uc29sZS5sb2coJ2EyJykKICByZXR1cm4gJ2EnICAKfQpmdW5jdGlvbiBiKCl7CiAgICBjb25zb2xlLmxvZygnYjEnKQogICAgYygpCiAgICBjb25zb2xlLmxvZygnYjInKQogICAgcmV0dXJuICdiJwp9CmZ1bmN0aW9uIGMoKXsKICAgIGNvbnNvbGUubG9nKCdjJykKICAgIHJldHVybiAnYycKfQphKCkKY29uc29sZS5sb2coJ2VuZCcp!!!)
   - [递归](http://latentflip.com/loupe/?code=ZnVuY3Rpb24gZmFiKG4pewogICAgY29uc29sZS5sb2coJ3N0YXJ0IGNhbGMgZmFiICcrIG4pCiAgICBpZihuPj0zKXsKICAgICAgICByZXR1cm4gZmFiKG4tMSkgKyBmYWIobi0yKQogICAgfWVsc2V7CiAgICAgICAgcmV0dXJuIDEKICAgIH0KfQoKZmFiKDUp!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D)

4. this & arguments

   - 重要：[this 就是 call 的第一个参数！call 的其他参数统称为 arguments](https://zhuanlan.zhihu.com/p/23804247)
     如果你记住了这个规则，那么网上其他关于 this 的解释在此时都变得很啰嗦了。

   - this 是隐藏的第一个参数，且一般是对象（如果不是对象，就显得很没有意义了）

     ```js
       function f(){
           console.log(this)
           console.log(arguments)
       }
       f.call() // window
       f.call({name:'frank'}) // {name: 'frank'}, []
       f.call({name:'frank'},1) // {name: 'frank'}, [1]
       f.call({name:'frank'},1,2) // {name: 'frank'}, [1,2]
     ```

   - this 为什么必须是对象
     因为 this 就是函数与对象之间的羁绊

     ```js
           var person = {
               name: 'frank',
               sayHi: function(person){
                   console.log('Hi, I am' + person.name)
               },
               sayBye: function(person){
                   console.log('Bye, I am' + person.name)
               },
               say: function(person, word){
                   console.log(word + ', I am' + person.name)
               }
           }
           person.sayHi(person)
           person.sayBye(person)
           person.say(person, 'How are you')
     
           // 能不能变成 
           person.sayHi()
           person.sayBye()
           person.say('How are you')
     
           // 那么源代码就要改了
           var person = {
               name: 'frank',
               sayHi: function(){
                   console.log('Hi, I am' + this.name)
               },
               sayBye: function(){
                   console.log('Bye, I am' + this.name)
               },
               say: function(word){
                   console.log(word + ', I am' + this.name)
               }
           }
           // 如果你不想吃语法糖
           person.sayHi.call(person)
           person.sayBye.call(person)
           person.say.call(person, 'How are you')
     
           // 还是回到那句话：this 是 call 的第一个参数
           // this 是参数，所以，只有在调用的时候才能确定
           person.sayHi.call({name:'haha'})  // 这时 sayHi 里面的 this 就不是 person 了
           // this 真的很不靠谱
     
           // 新手疑惑的两种写法
           var fn = person.sayHi
           person.sayHi() // this === person
           fn()  // this === window
     ```

5. call / apply
   fn.call(asThis, p1,p2) 是函数的正常调用方式
   当你不确定参数的个数时，就使用 apply
   fn.apply(asThis, params)

6. bind
   call 和 apply 是直接调用函数，而 bind 则是返回一个新函数（并没有调用原来的函数），这个新函数会 call 原来的函数，call 的参数由你指定。

7. return
   每个函数都有 return
   如果你不写 return，就相当于写了 return undefined

8. 柯里化 / 高阶函数
   返回函数的函数

   - 柯里化：将 f(x,y) 变成 f(x=1)(y) 或 f(y=1)x

     ```js
       //柯里化之前
       function sum(x,y){
           return x+y
       }
       //柯里化之后
       function addOne(y){
           return sum(1, y)
       }
       //柯里化之前
       function Handlebar(template, data){
           return template.replace('{{name}}', data.name)
       }
       //柯里化之后
       function Handlebar(template){
           return function(data){
               return template.replace('{{name}}', data.name)
           }
       }
     ```

     柯里化可以将真实计算拖延到最后再做

     关于柯里化的高级文章：

     1. <http://www.yinwang.org/blog-cn/2013/04/02/currying>
     2. <https://zhuanlan.zhihu.com/p/31271179>

   - 高阶函数：

     在数学和计算机科学中，高阶函数是至少满足下列一个条件的函数：

     1. 接受一个或多个函数作为输入：forEach sort map filter reduce
     2. 输出一个函数：lodash.curry
     3. 不过它也可以同时满足两个条件：Function.prototype.bind

9. 回调
   名词形式：被当做参数的函数就是回调
   动词形式：调用这个回调
   注意回调跟异步没有任何关系

10. 构造函数
    返回对象的函数就是构造函数
    一般首字母大写

课后题答案：

```js
function curry(func , fixedParams){
    if ( !Array.isArray(fixedParams) ) { fixedParams = [ ] }
    return function(){
        let newParams = Array.prototype.slice.call(arguments); // 新传的所有参数
        if ( (fixedParams.length+newParams.length) < func.length ) {
            return curry(func , fixedParams.concat(newParams));
        }else{
            return func.apply(undefined, fixedParams.concat(newParams));
        }
    };
}
```

## ★概述

我们会讲函数相关的很多细节知识！如，函数的3种声明方式！、this&argument这2个隐含的变量、柯里化/高阶哈数等这些概念，可见我们需要讲的概念很多，而你需要做的就是记笔记！

这个课程是JavaScript的高阶课！如果你发现有很多东西不懂，那么最好的姿势就是记笔记，写博客……

芳芳平时买书看，都会在看书的同时，用一个小本来做笔记，即把书上重要的知识给记下来！这样在回顾的时候就更快了，不用每次都重新看！

当然你可以把课程简介中的讲义当作笔记，不过我希望你能把其中的那些链接都给点一遍！毕竟这些链接都是一些比较深入的资料

## ★函数声明

JS中目前有3种函数的声明方式，分别是

- 匿名函数
- 具名函数
- 箭头函数

### ◇匿名函数

声明函数的时候，不要给名字！就像下面这行demo一样，**✎：**

```js
function() {
    return 1
}
```

不过，你直接运行是会报错的！

因为你声明了一个函数，但是你又不能引用到它！所以这就相当于一个「废话」了呀！为此，一般浏览器都不会让这种函数可以过的，即会告诉你报错了！

那么如何才能让它过呢？

我们需要给它一个引用，**✎：**

```js
var fn = function() {
    return 1
}
```

这个fn就引用了这个函数！

> 其实也就是说，匿名函数要给变量一个引入自己的机会才行！可是，箭头函数呢？这家伙可没有名字，也能自行执行也不报错！

为什么说是「引用」呢？

首先，这个匿名函数是一个对象对吧！可见，这个匿名函数是存储在堆内存里面的！

其次，说到堆内存，显然就有个叫「地址」的概念！

所以，这个fn记录的是这个匿名函数的地址，而不是该函数本身！

> 关于对「引用」的理解，我们在日常中为了让自己所讲的话更具有说服力，为此我们时常用明引的姿势，如，**✎：**「宋代[欧阳修](https://www.wikiwand.com/zh/%E6%AD%90%E9%99%BD%E4%BF%AE)则云：『最佳读书时间，乃为三上：即枕上、马上、厕上。』」
>
> **➹：**[引用 - Wikiwand](https://www.wikiwand.com/zh/%E5%BC%95%E7%94%A8)
>
> 我们的fn引用了一个匿名函数，这也就是说通过fn我们是可以使用这个函数的！这就像是那些名言不是我们自己所想，不是我们第一个说的，但是我们是可以使用它们来为我们自身服务的，当然，你最好指明出处才行，不然这是很不道德的！

言归正传，我们如何才能体现这个fn存储的是一个地址呢？

```js
var fn = function() {
    return 1
}
var fn2 = fn
```

在这里，我们把fn1赋值给了fn2，然后你打印一下 `fn.name`和 `fn2.name`的值，你会发现他们都是fn，**✎：**

![1543371716802](img/02/1543371716802.png)

我在想为啥都是fn呢？我把fn2赋值给fn3，看看fn3.name是fn还是fn2，**✎：**

![1543372038789](img/02/1543372038789.png)

我想了想，谁叫这个fn是第一个引用匿名函数的变量啊！这就像是这个匿名函数是有版权的，版权归属为fn……

不过fn2、fn3，除了具有可读能力，还具有修改这个匿名函数的能力！这就像我可以把Linux当作是个匿名函数的，而我们都知道它的创造者是[林纳斯·托瓦兹](https://www.wikiwand.com/zh-cn/%E6%9E%97%E7%B4%8D%E6%96%AF%C2%B7%E6%89%98%E7%93%A6%E8%8C%B2)，如fn一样。当它开源后，如赋值一样，即出现了众多的为它贡献代码的开发者了！这也意味着Linux将会愈发地强大起来！

总之，匿名函数默认的name是fn，你会发现这很矛盾——**我是匿名函数，但是我有name**！

或许我可以这样理解，我们总得给一个东西一个名字，毕竟它确实存在于这个世界，不然「这个」「那个」的，沟通起来很不方便，如「这个」是啥？「那个」又是啥。由于匿名函数它确实在堆中，既然在堆中总得起个名字哈！或许是直观的name属性，或许是常用的给个地址，总之我们可以借助某种手段，能精确无误地找到这个东西就可以了

### ◇具名函数

具有名字的函数

```js
function fn3() {
    return 3
}
var fn5 = function fn4() {
    return fn4
}

```

fn3的作用域是全局的，毕竟它是声明在最顶级空间的，而fn4则不是全局的，而是，**✎：**

![1543376344740](img/02/1543376344740.png)

总之，匿名函数与具名函数的唯一区别就是有没有fn3、fn4……这个名字，但是它们都有name……

### ◇箭头函数

这个是es6的语法……

箭头函数有多少种写法呢？

如果只有一个参数，**✎：**

```js
var fn6 = i => i+1
fn6(6) //7
fn6(7) //8
```

接收一个i返回一个i+1，这就是所谓额输入和输出了，这是最简单的一种写法！

如果有2个参数呢？就像这样，**✎：**

```js
var fn7 = i,j => i+j
```

你说这样写行吗？不行哈！会报错

![1543377220760](img/02/1543377220760.png)

那么非要传2个参数，该如何才能让它不报错呢？

用括号括起来即可，**✎：**

```js
var fn8 = (i,j) => i+j
```

如果后面，即函数体中不止是一句话呢？

那么你需要用花括号把它们都括起来，同时还要把return的值给说清楚哈！

当然，如果只有一句话，你就不用写return了！但是如果是2句话的话，那么你就得显示的把这个return给说出来了！

```js
var fn9 = (i,j) => { console.log('我是用来测试作为第二句话的！'); return i+j }
```

以上就是箭头函数的用法了！至于区别，我们在讲this的时候才会知道，总之，大体来讲是没有区别的，而只有在this这个地方才会有区别哈！，**✎：**

![1543378390688](img/02/1543378390688.png)

---

以上就是函数的定义了，匿名函数、具名函数、箭头函数

其中匿名函数和具名函数，都有name，那么箭头函数有没有name呢？

也是有的，跟它们俩的规律是一样的，只是形式不同

总之，箭头函数跟它们俩唯一的不同点在`this`这个地方，而其它地方都是一样的！

## ★词法作用域



