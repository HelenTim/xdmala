---
typora-copy-images-to: img\02
---

# 你真的懂函数吗？（下）

## ★柯里化

### ◇大概内容

> 返回函数的函数

柯里化：将 f(x,y) 变成 f(x=1)(y) 或 f(y=1)(x)

```
		  //柯里化之前
  function sum(x,y){
      return x+y
  }
  //柯里化之后
  function addOne(y){
      return sum(1, y)
  }
  //柯里化之前
  function Handlebar(template, data){
      return template.replace('{{name}}', data.name)
  }
  //柯里化之后
  function Handlebar(template){
      return function(data){
          return template.replace('{{name}}', data.name)
      }
  }
```

柯里化可以将真实计算拖延到最后再做

关于柯里化的高级文章：

1. <http://www.yinwang.org/blog-cn/2013/04/02/currying>
2. <https://zhuanlan.zhihu.com/p/31271179>

---

看了一些关于函数的定义之后，**✎：**

把sum函数看作是：`sum(x,y) = x + y`

而addOne则是：`addOne(y) = sum(1,y)=1+y`

ps：上面那个柯里化后的第一个demo，你得这样看才行：

```js
//柯里化之前
function sum(x,y){
      return x+y
}

//柯里化之后
function sum(x){
    return function (y) {
      return x + y
  	}
}
```

把addOne那个代码看作是上面这个柯里化之后的返回值——匿名函数就好了！

> 如果你的函数的返回值是一个函数，那么你的函数就会有一个特殊的名字……

#### 柯里化

数学里有这么一个概念：

```js
z = f(x,y) = x + 2y
```

z是关于x和y的一个函数……

假如我们把x的值给指定好了：

```js
g = f(x=1,y) = 1 + 2y
```

可见g是关于y的一个函数

那g和z的是关系是什么呢？

z根据2个变量来动，而g则是根据一个变量来动……

所以g和z的关系就是「g叫做z的偏函数（Partial function）」，即g只是z的一部分

而柯里化基本上就是这样——**把一个函数其中的一个参数给固定下来得到一个新的函数**

举个栗子，**✎：**

有一个求值函数，即sum函数，它是关于x和y的这样一个函数

```js
function sum(x,y) {
    return x + y 
}
```

如果我们这样写：

```js
function addOne(y) {
    return sum(1,y)
}
```

addOne就是把sum的x参数固定成1，然后再加上后面的数——y

所以当你 `addOne(6)`的时候，那么结果就是7啦！

同理，我们再写个addTwo：

```js
function addTwo(y) {
    return sum(2,y)
}
```

那么 `addTwo(3)`就是5啦！

这就是所谓的柯里化……

那么柯里化有什么意义呢？——目前来说，只是一个形式上的变化，但是它确实是有一定意义的！以我们早期的前端的模板引擎为例……

比如说我们有这样一个需求「给我一个模板字符串，再给我一个数据，我就能给你返回一个HTML」

![1544766798489](img/02/1544766798489.png)

我们的template写得很简单，template就只能有一个叫做name的东西，至于大胡子`{{}}`只是用于占个位而已，因为好识别……然后把里面的`name`改成`data.name`，接着就是把它给return出来了……

当我们调用这个handlebar的时候，你会发现这函数就是把字符串和对象里面的东西给结合起来！

这就是模拟的一个假的 handlebar了！

然而这样是有一个问题的，就是你会写很多次一样的字符串，如，我换个名字，你就得再来一遍这样的：

![1544767841702](img/02/1544767841702.png)

所以，我们能不能只写一次呢？因为我们这个模板经常在各个地方需要被用到，简而言之，它就是一个很复用的模板

所以咋办呢？

嗯……试试这样做——用一个变量接收这个模板：

![1544768173659](img/02/1544768173659.png)

然而，函数式编程它基本不会频繁的做这样的变量声明，为此每次调用handlebar都要传一个template……所以，它想对你说「为啥不声明一个柯里化的函数呢？」

就像这样：

![1544768634104](img/02/1544768634104.png)

这个Handlebar2函数需要被调用两次，第一次会把template给记下来，第二次它才会真正地渲染

我们是如何写这个Handlebar2的？——return一个函数，而这个函数是接收这个data的，而Handlebar2它自己只接收一个template。

测试：

t是个函数，它会接收一个数据。当我们调用t的时候，字符串才会和所传的这个数据结合到一起！

总之，你给了template，并不会渲染什么东西，等你把数据给了之后，才会去渲染，即把data里的东西填到模板里去，**✎：**

![1544769886407](img/02/1544769886407.png)

好了，这就是柯里化在模板引擎里的使用了，但是现在用得很少！因为意义并没有特别大！当然，它可以用来做惰性求值！

那么什么是「惰性求值」呢？——就是你在调我第一个函数的时候	，如调用Handlebar2函数得到的t函数，其实啥也没做，即只是return了一个函数而已！如果说「我们需要对这个字符串做很重的操作，比如说什么正则啊、什么Ajax啊……」，那如果我们直接在函数声明的时候就调，可能会显得有点麻烦，还不如在某个时间真正地使用这些重操作，然后再去调，再去生效，如第二次调用的时候才真正地生效，这就是惰性求值了！

简而言之，你第一次调用Handlebar2的时候啥也没做，Handlebar2只是在你最后一次真正调的时候才去做一些事情！

所以说柯里化在惰性求值这一方面还是有点意义的，但是在其它方面，我觉得它就是一个形式（做做样子、装装逼）而已！

以上就是对柯里化的了解了……

## ★高阶函数

### ◇大概内容

在数学和计算机科学中，高阶函数是至少满足下列一个条件的函数：

1. 接受一个或多个函数作为输入：forEach sort map filter reduce
2. 输出一个函数：lodash.curry
3. 不过它也可以同时满足两个条件：Function.prototype.bind

### ◇仔细分析一波

高阶函数？看起来很高端，实际上很low很low……

我们从[维基百科](https://www.wikiwand.com/zh-hans/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0)上可以看到关于它的定义，就这么一句话：

> 在[数学](https://www.wikiwand.com/zh-hans/%E6%95%B0%E5%AD%A6)和[计算机科学](https://www.wikiwand.com/zh-hans/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)中，**高阶函数**是指至少满足下列一个条件的[函数](https://www.wikiwand.com/zh-hans/%E5%87%BD%E6%95%B0)：
>
> - 接受一个或多个函数作为输入
> - 输出一个函数

如果函数接受函数作为输入或者函数它输出一个函数，那么它就是高阶函数，当然，它也可以同时满足既输入函数又输出函数！

可见，这样的例子是非常多的！如：

#### 接收一个或多个函数作为输入

我们学到的第一个高阶函数就是 `array.sort()`啦！

![1544806422777](img/02/1544806422777.png)

这个sort函数接收一个函数，用来比较数组里面的大小！a-b>0，就a大，否则a就是小的……根据a-b的结果是大于0还是小于0，我们就知道怎么去排列这个array了……

**➹：**[Array.prototype.sort() - MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)

那么还有哪些呢？

- `array.forEach(function(){})`
- `array.map(function(){})`

- `array.filter(function(){})`
- `array.reduce(function(){})`
- ……

如果你不清楚它们的用法可以去看一下MDN……

**➹：**[Array - MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array)

这几个函数都接受了一个函数参数，所以它们是高阶函数……

> 我在想函数就是函数，为啥还要加个「高阶」呢？其实这就像是给函数分了个类一样……在生活中，我们时常需要分类，如厨房就放置一些做菜的工具，卧室当然就得有张床啦！总不能把床放到厨房中吧！还有在网上购物的时候，总会有很多分类选项供你点击……总不能把所有东西都统称为「商品」吧！不然，不然检索起来岂不是一团糟……
>
> 总之，我们分好了类，才可以更好地记忆它们……

#### 输出一个函数

这种我们有没有见过嘞？

之前讲到过的bind函数就是这样的……

当你用call的时候，call的第一个参数就是一个函数fn，这个函数会被bind包转成另一个函数，也就是bind会返回一个新的函数，然后这个新函数的肚子里会调用这个fn，而在调用fn的时候会接收一些参数，就像这样：

```js
fn.bind.call(fn,arg1,arg2,……)
```

fn作为bind里的this，而arg1则是作为fn.call()的第一个参数……而arg2等后面的参数就是fn的输入参数啦！

这就是我们所学过的输出一个函数的高阶函数——bind……

当然，你也可以认为`new Function('x','y','x+y')`也是输出一个函数的！但是这个不太典型……

我们在更多的时候会认为它是一个构造函数！

#### 二者兼顾

bind就是这样的函数……输入一个fn，输出一个新的函数，包含着fn……

回顾柯里化，你会发现高阶函数与柯里化（将函数的参数个数变少，然后输出一个新的函数）是有交叉部分的，毕竟柯里化后的函数总是返回一个偏函数或者说是匿名函数……

而函数只要满足输出一个函数，那它就是高阶函数了……所以高阶函数的范围更广一点

总之bind是一个非常标准的高阶函数！为什么说它非常标准呢？因为它符合所有的条件，它可以接收一个函数，同时又输出一个新的函数，

#### 有什么用呢？

高阶函数有什么用呢？——它有一个特别重要的作用就是「**它可以将函数任意地组合！**」

以我们数组所提供的那几个API为例……

**①需求：找出数组里的所有偶数，并它们都加起来**

![1544868596715](img/02/1544868596715.png)

正常来说，我们会通过一个for循环遍历一下数组，可见这个思想是很程序员化的！然后求模，加起来，最后输出……

可是为啥不这么做呢？——直接找出所有的偶数——通过filter函数可以做到，接着就是用reduce归纳了……

![1544869072183](img/02/1544869072183.png)

以上这种是用面向对象的形式来写的！

ps：reduce（归纳）、n%2（读作n模的2）

filter函数是返回一个新数组，对array数组没有副作用。同样reduce也是个纯函数！关于reduce的第二个参数：

![1544877725961](img/02/1544877725961.png)

如果我们想改成非常非常的函数式写法：

![1544878668350](img/02/1544878668350.png)

我们这个filter函数接收一个array数组，然后再接收一个函数。由于接收一个函数，所以filter就是一个高阶函数啦！为什么要接收一个函数呢？因为这个函数是一种筛选规则啊！如只要元素为偶数的……这样就得到了一个 `[0,2,4,6,8]`的新数组啦！

> 似乎可以把传入函数看作是传入一种计算规则……

接着我们reduce这个新数组，那么怎么reduce呢？我们需要给这个reduce函数传一个函数，所传的这个函数是告诉reduce如何去把第一个参数给压缩一下，如压缩成20（0+2+4+6+8）……然后还有一个参数是初始值等于0！

reduce这步操作就相当于是我们之前遍历然后累加的结果，即把几句话变成一句话了！

**②需求：把一个数组里面的所有单数（奇数）给找出来，然后给它们排序**

![1544880277722](img/02/1544880277722.png)

1. 找出所有单数：

   ```js
   filter(array,function(n){ return n%2 === 1})
   ```

   返回一个都是单数元素的数组，然后对这个数组排序，那么怎么排呢？——直接sort一下就好了

2. 排序：

   ```js
   sort(filter(array,function(n){ return n%2 === 1}),function(a,b) {return a-b})
   ```

   sort这个数组需要给判断依据才行，因为我们需要判断1和3到底哪个大，我们一眼就能看出来哪个大，但是机器是不知道的哈！当然，这个sort函数默认是从小到大排列了，可万一我们是打算倒着排呢？即从大到小呢？所以我们必须得告诉sort一个函数！——这个函数就是如果有两个数字，那么就用「前面的数字减后面的数字」的值当作是排序的依据就行了！

   总之，这行demo的意思就是找出所有单数，然后进行一个从小到大的排列……

如果不用函数式的姿势写，如之前的那种循环、遍历数组、累加会很不直观，而用高阶函数的这种（上面那行代码）会很直观！

对于filter、sort等这些函数，我们在Underscore（下划线）或者是Lodash中，都可以找到如何去写！总之就是「reduce怎么写」「sort怎么写」都可以从这两个JavaScript工具库中找到……

**➹：**[Underscore.js 中文文档](http://www.bootcss.com/p/underscore/#)

**➹：**[Underscore.js](https://underscorejs.org/)

**➹：**[Lodash 中文文档 - Lodash 中文网](https://www.lodashjs.com/)

目前，高阶函数在前端比较流行。为什么这么说呢？——就是因为它有这种很「直观」的特性

我们知道在React里面	，每一个组件其实就是一个纯函数，可以是一个纯函数。那如果一个组件是一个纯函数，那么组件和组件是不是能互相转化，然后互相使用呢？

所以高阶函数就在前端火起来了！

你有了高阶函数就可以把各种函数给组合起来，如这个函数接收另一个函数，然后返回一个新的东西，而这个新的东西可以作为另一个函数的参数，也可以作为另一个函数……

总之，高阶函数还是很有用的！

如果你不知道高阶函数是什么，那就回想起之前所讲到的那几个函数，如sort、forEach、filter……它们都是接受一个函数，然后对数组做一些事情

额……下图中，左边那种姿势不太好，对于纯函数来说，还是用call比较好，为什么这么说呢？——因为你用了call之后，你才能真正地理解什么叫函数：

![1544882962077](img/02/1544882962077.png)

> 似乎「纯」也可以体现在显示地指定了this值，这样一来这个函数看起来就像是独立的一样，不需要关注这个函数的点前面是什么鬼东西，我们只需要关注：`输入、关系、输出`就好了

再次回顾这几个函数的用法：

- sort：对array进行排序，排序的依据就是后面那个函数fn
- forEach：传一个array，对这个array进行遍历
- map：对array的每一个元素进行一个转化
- filter：接受一个数组，对这个数组的每一项进行过滤
- reduce：也是接受一个数组，对这个数组的每一项进行累加或者是其它操作，总之所有的操作都放到fn里边
- bind：接受一个fn作为this，然后对this进行操作，然后操作的时候就是调用这个this，即调用这个fn，而fn的参数就是之后的那几个参数，而fn的调用形式肯定是call的那种形式，而不是那种智障姿势，即直接加括号的那种形式。总之就是用call的形式，不会用括号的那种形式

现在的你可能对高阶函数理解得不深刻，等你在React里面用到高阶函数的时候，你就会特别深刻了！——不就是他妈的接受一个函数，然后返回一个函数吗？

好了，这就是高阶函数啦……

























---

## ★总结

- 目前了解到柯里化在惰性求值方面有点意义……柯里化就像是把一个函数给进化了一样，这似乎就是在减少我们在调用函数时所传的参数个数，你会发现「一个输入就一个输出是很简洁的！」，如有两个函数——`f(x) = 2x`和`f(x,y)=x+2y`，假如只传一个参数，那么就是 `2→4`；如果有两个参数，那么就是 `(1,2)→5`。总之我们只是喜欢只有一个东西与另外一个东西有关系，而不是有两个或两个以上的东西与另外一个东西有关系！
- 把函数给分类了，因为有些函数会改变它的调用者，而有些则不会，为此就有了纯函数的分类……总之，把函数给分类了，这样当你看到某种函数的时候会为它们贴上标签……就能更好地使用它们了！

## ★Q&A

### ①什么是函数？

有很多方法可以去描述函数，但所有方法都离不开这三个主要部分，**✎：**

- 输入
- 关系
- 输出

以下是关于函数的**一般概念**，不谈其它的个别函数。**✎：**

![](img/02/1.svg)



ps：读作「*"f x 等于 x 平方"*」

这张图可以表示为，**✎：**

| 输入 | 关系 | 输出 |
| ---- | ---- | ---- |
| x    | `*x` | x^2^ |

说到函数首先得有个名字才行，最常见的叫`f`，当然还有其它的，如`g`、`果酱`等

我们把函数的**输入值**放在函数名字后面的括号`（）`中间：

> 所以 **f(x)** 的意思是函数叫 `"f"`，而 `"x"` 是**输入值**

函数对输入值进行的运作：

> **f(x) = x^2^** 显示函数 `"f"` 取输入值 `"x"` 的平方。

根据下面这个函数，


$$
f(x) = x^2
$$


我们假设输入为4，那么输出就是16了，所以我们可以这样


$$
f(4)=16
$$


一些注意点，**✎：**

- `"x"` 只是个位置标志符！,也就是说，你可以换成是其它符号，如q、z等什么的，而且这些符号还有个名字，叫自变量

- 函数有时没有名字，如  y = x^2^

  不过，这个函数仍然有，**✎：**

  - 输入（x）

  - 关系（取平方）
  - 输出（y）

- 「关系」：函数显示输入与输出的**关系**。"**f(4) = 16**" 就是说 4 和 16 是有关系的：4 → 16，而这个关系就是 f。举个例子就是「一棵树每年长高 20厘米」，那么树的高度和它年龄的关系可以用函数h来显示，**✎：**

  `h(年龄) = 年龄 × 20`

  所以，如果年龄是 10年，高度就是：

  `h(10) = 10 × 20 = 200厘米`

  > 输入和输出之间的关系可以用函数来表示，如树的年龄知道了，那么树的高度也就知道了，然而为啥会知道呢？因为有个函数可以描述它们之间的关系啊！
  >
  > 就像是我们俩的关系是男女朋友，然后输入一个「我爱你」，输出一个「我也爱你」

- 函数处理什么？最常见是数字，当然输入也可以是字母等其它特别的字符

- 对函数的另一个看法：把函数的输入和输出为一个 "序偶"，例如 (4,16)。这就是坐标了。函数可以被定义为序偶的**集**，而坐标的集也是函数

一些结论，**✎：**

> - 函数显示输入与输出的**关系**
>
> - 函数把一个集（**定义域**的元素联系到另一个集（陪域）的元素。
>
> - 所有的输出值（陪域里实际与定义域有关系的元素）的集叫**值域**
>
> - 特别关系：
>
>   - 包含定义域里**每个元素**，
>   - 任何输入值**只有一个输出值**（不能是一个**或**另一个输出值）
>
> - 一个输入值和它的输出值一起就叫做**序偶**
> - 所以函数也可以被视为一个**序偶的集**

抛开以上的一切内容，把函数看作是一个实现某种**功能**的工具（盒子），就像这样，**✎：**

![preview](img/02/cd7c0a4d89e853da418514d6aae7d1ab_r.jpg)

函数d就是一个盒子，将输入的x转化为输出的y

> 在我看来这就像是拿一个东西去换另一个东西（注意：只能换同一件东西），至于换成是什么，到底值不值，这就看这个函数是如何定义的了，即「这个兑换规则是怎样的」或者说「这个东西和另外一个东西之间的关系是怎样的」
>
> 回到编程，或许把function翻译成「功能」比较好
>
> ps：联想到LOL，如何补刀呢？如何让这个小兵的最后一下是由你操纵的这个英雄给终结的呢？你输入一个平A，你要想得到这个小兵的经济，那么平A和小兵的经济的关系可以用一个函数f来表示，而这个函数该如何去写呢？按照我的经验，这会分很多情况，不过我一般都是凭感觉去补刀的，所以这不会保证自己一定会得到小兵的经济，除非周边没有其它家伙在攻击敌方小兵，而是只有自己操纵的那一个英雄……
>
> 所以说一个函数写得好不好，还是很重要的……因为写得不好的话，那么结果就有一定几率不是你想要的！如果我要用一个名字形容这样的函数的话，我会叫做「过家家函数」，似乎也可以叫做「玩具函数」，总之就是简单得可以搞一下，复杂一点的就不行了……
>
> 额……函数到底是关系（映射）？还是说函数让输入和输出有了关系呢？



---

**➹：**[函数是什么](https://www.shuxuele.com/sets/function.html)

**➹：**[函数 - Wikiwand](https://www.wikiwand.com/zh-hans/%E5%87%BD%E6%95%B0)

**➹：**[你对函数的理解是什么？ - 知乎](https://www.zhihu.com/question/21301730)

**➹：**[数学和编程](http://www.yinwang.org/blog-cn/2015/07/04/math)

### ②什么是 Lambda 演算？

**➹：**[Λ - Wikiwand](https://www.wikiwand.com/zh-hans/%CE%9B)

**➹：**[λ演算 - Wikiwand](https://www.wikiwand.com/zh-hans/%CE%9B%E6%BC%94%E7%AE%97)

**➹：**[什么是 Lambda 演算？ - 知乎](https://www.zhihu.com/question/21936396)

**➹：**[认知科学家写给小白的Lambda演算 - 知乎](https://zhuanlan.zhihu.com/p/30510749)

**➹：**[Good Math/Bad Math的Lambda演算系列的中文翻译 · cgnail's weblog](http://cgnail.github.io/academic/lambda-index/)

### ③函数式编程？

**➹：**[编程的智慧](http://www.yinwang.org/blog-cn/2015/11/21/programming-philosophy)

**➹：**[编程的宗派](http://www.yinwang.org/blog-cn/2015/04/03/paradigms)

**➹：**[JavaScript 函数式编程（一） - 掘金](https://juejin.im/post/5b7014d5518825612d6441f8)

**➹：**[functional-programming-in-javascript](http://slides.com/yangzhenyu/functional-programming-in-javascript#/)

### ④取余？

> 取模和求余应该是同一种运算，只是在被除数和除数符号不同时，余数的符号是有歧义的，可为正也可为负。不同的编程语言对此有不同的处理。
>
> C语言中取模运算 % 结果与**被除数同符号**。大部分编程语言都是这样，比如Go，C#，Java，Rust，Swift，JavaScript，PHP。
>
> Python 中取模运算 % 结果与除数同符号。同时Python中函数 **math.fmod** 提供了与C语言中一致的取模运算。
>
> 一般来说，还是 **取模结果与被除数同符号** 比较符合大多数情况。否则商向零取整不满足等式 **被除数=除数\*商+模**



![1544876098200](img/02/1544876098200.png)

**➹：**[编程语言中，取余和取模的区别到底是什么？ - 知乎](https://www.zhihu.com/question/30526656)

**➹：**[模除 - Wikiwand](https://www.wikiwand.com/zh/%E6%A8%A1%E9%99%A4)

### ⑤纯函数？

> 纯函数是这样一种函数，即相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用。

```js
var xs = [1,2,3,4,5];

// 纯的
xs.slice(0,3);
//=> [1,2,3]

xs.slice(0,3);
//=> [1,2,3]

xs.slice(0,3);
//=> [1,2,3]


// 不纯的
xs.splice(0,3);
//=> [1,2,3]

xs.splice(0,3);
//=> [4,5]

xs.splice(0,3);
//=> []
```

嗯，一些函数把调用它的数组给搞坏了……而这些函数就不是纯函数了……

**➹：**[第 3 章: 纯函数的好处 · JS 函数式编程指南](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch3.html)

**➹：**[纯函数 - Wikiwand](https://www.wikiwand.com/zh-hans/%E7%BA%AF%E5%87%BD%E6%95%B0)



