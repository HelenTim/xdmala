---
typora-copy-images-to: img\02
---

# 你真的懂函数吗？（下）

## ★柯里化

### ◇大概内容

> 返回函数的函数

柯里化：将 f(x,y) 变成 f(x=1)(y) 或 f(y=1)(x)

```
  //柯里化之前
  function sum(x,y){
      return x+y
  }
  //柯里化之后
  function addOne(y){
      return sum(1, y)
  }
  //柯里化之前
  function Handlebar(template, data){
      return template.replace('{{name}}', data.name)
  }
  //柯里化之后
  function Handlebar(template){
      return function(data){
          return template.replace('{{name}}', data.name)
      }
  }
```

柯里化可以将真实计算拖延到最后再做

关于柯里化的高级文章：

1. <http://www.yinwang.org/blog-cn/2013/04/02/currying>
2. <https://zhuanlan.zhihu.com/p/31271179>

---

看了一些关于函数的定义之后，**✎：**

把sum函数看作是：`sum(x,y) = x + y`

而addOne则是：`addOne(y) = sum(1,y)=1+y`

ps：上面那个柯里化后的第一个demo，你得这样看才行：

```js
//柯里化之前
function sum(x,y){
      return x+y
}

//柯里化之后
function sum(x){
    return function (y) {
      return x + y
  	}
}
```

把addOne那个代码看作是上面这个柯里化之后的返回值——匿名函数就好了！

> 如果你的函数的返回值是一个函数，那么你的函数就会有一个特殊的名字……

#### 柯里化

数学里有这么一个概念：

```js
z = f(x,y) = x + 2y
```

z是关于x和y的一个函数……

假如我们把x的值给指定好了：

```js
g = f(x=1,y) = 1 + 2y
```

可见g是关于y的一个函数

那g和z的是关系是什么呢？

z根据2个变量来动，而g则是根据一个变量来动……

所以g和z的关系就是「g叫做z的偏函数（Partial function）」，即g只是z的一部分

而柯里化基本上就是这样——**把一个函数其中的一个参数给固定下来得到一个新的函数**

举个栗子，**✎：**

有一个求值函数，即sum函数，它是关于x和y的这样一个函数

```js
function sum(x,y) {
    return x + y 
}
```

如果我们这样写：

```js
function addOne(y) {
    return sum(1,y)
}
```

addOne就是把sum的x参数固定成1，然后再加上后面的数——y

所以当你 `addOne(6)`的时候，那么结果就是7啦！

同理，我们再写个addTwo：

```js
function addTwo(y) {
    return sum(2,y)
}
```

那么 `addTwo(3)`就是5啦！

这就是所谓的柯里化……

那么柯里化有什么意义呢？——目前来说，只是一个形式上的变化，但是它确实是有一定意义的！以我们早期的前端的模板引擎为例……

比如说我们有这样一个需求「给我一个模板字符串，再给我一个数据，我就能给你返回一个HTML」

![1544766798489](img/02/1544766798489.png)

我们的template写得很简单，template就只能有一个叫做name的东西，至于大胡子`{{}}`只是用于占个位而已，因为好识别……然后把里面的`name`改成`data.name`，接着就是把它给return出来了……

当我们调用这个handlebar的时候，你会发现这函数就是把字符串和对象里面的东西给结合起来！

这就是模拟的一个假的 handlebar了！

然而这样是有一个问题的，就是你会写很多次一样的字符串，如，我换个名字，你就得再来一遍这样的：

![1544767841702](img/02/1544767841702.png)

所以，我们能不能只写一次呢？因为我们这个模板经常在各个地方需要被用到，简而言之，它就是一个很复用的模板

所以咋办呢？

嗯……试试这样做——用一个变量接收这个模板：

![1544768173659](img/02/1544768173659.png)

然而，函数式编程它基本不会频繁的做这样的变量声明，为此每次调用handlebar都要传一个template……所以，它想对你说「为啥不声明一个柯里化的函数呢？」

就像这样：

![1544768634104](img/02/1544768634104.png)

这个Handlebar2函数需要被调用两次，第一次会把template给记下来，第二次它才会真正地渲染

我们是如何写这个Handlebar2的？——return一个函数，而这个函数是接收这个data的，而Handlebar2它自己只接收一个template。

测试：

t是个函数，它会接收一个数据。当我们调用t的时候，字符串才会和所传的这个数据结合到一起！

总之，你给了template，并不会渲染什么东西，等你把数据给了之后，才会去渲染，即把data里的东西填到模板里去，**✎：**

![1544769886407](img/02/1544769886407.png)

好了，这就是柯里化在模板引擎里的使用了，但是现在用得很少！因为意义并没有特别大！当然，它可以用来做惰性求值！

那么什么是「惰性求值」呢？——就是你在调我第一个函数的时候	，如调用Handlebar2函数得到的t函数，其实啥也没做，即只是return了一个函数而已！如果说「我们需要对这个字符串做很重的操作，比如说什么正则啊、什么Ajax啊……」，那如果我们直接在函数声明的时候就调，可能会显得有点麻烦，还不如在某个时间真正地使用这些重操作，然后再去调，再去生效，如第二次调用的时候才真正地生效，这就是惰性求值了！

简而言之，你第一次调用Handlebar2的时候啥也没做，Handlebar2只是在你最后一次真正调的时候才去做一些事情！

所以说柯里化在惰性求值这一方面还是有点意义的，但是在其它方面，我觉得它就是一个形式（做做样子、装装逼）而已！

以上就是对柯里化的了解了……

## ★高阶函数

### ◇大概内容

在数学和计算机科学中，高阶函数是至少满足下列一个条件的函数：

1. 接受一个或多个函数作为输入：forEach sort map filter reduce
2. 输出一个函数：lodash.curry
3. 不过它也可以同时满足两个条件：Function.prototype.bind

### ◇仔细分析一波

高阶函数？看起来很高端，实际上很low很low……

我们从[维基百科](https://www.wikiwand.com/zh-hans/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0)上可以看到关于它的定义，就这么一句话：

> 在[数学](https://www.wikiwand.com/zh-hans/%E6%95%B0%E5%AD%A6)和[计算机科学](https://www.wikiwand.com/zh-hans/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)中，**高阶函数**是指至少满足下列一个条件的[函数](https://www.wikiwand.com/zh-hans/%E5%87%BD%E6%95%B0)：
>
> - 接受一个或多个函数作为输入
> - 输出一个函数

如果函数接受函数作为输入或者函数它输出一个函数，那么它就是高阶函数，当然，它也可以同时满足既输入函数又输出函数！

可见，这样的例子是非常多的！如：

我们学到的第一个高阶函数就是 `array.sort()`啦！

![1544806422777](img/02/1544806422777.png)

这个sort函数接收一个函数，用来比较数组里面的大小！a-b>0，就a大，否则a就是小的……根据a-b的结果是大于0还是小于0，我们就知道怎么去排列这个array了……

**➹：**[Array.prototype.sort() - MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)



































---

## ★总结

- 目前了解到柯里化在惰性求值方面有点意义……柯里化就像是把一个函数给进化了一样，这似乎就是在减少我们在调用函数时所传的参数个数，你会发现「一个输入就一个输出是很简洁的！」，如有两个函数——`f(x) = 2x`和`f(x,y)=x+2y`，假如只传一个参数，那么就是 `2→4`；如果有两个参数，那么就是 `(1,2)→5`。总之我们只是喜欢只有一个东西与另外一个东西有关系，而不是有两个或两个以上的东西与另外一个东西有关系！

## ★Q&A

### ①什么是函数？

有很多方法可以去描述函数，但所有方法都离不开这三个主要部分，**✎：**

- 输入
- 关系
- 输出

以下是关于函数的**一般概念**，不谈其它的个别函数。**✎：**

![](img/02/1.svg)



ps：读作「*"f x 等于 x 平方"*」

这张图可以表示为，**✎：**

| 输入 | 关系 | 输出 |
| ---- | ---- | ---- |
| x    | `*x` | x^2^ |

说到函数首先得有个名字才行，最常见的叫`f`，当然还有其它的，如`g`、`果酱`等

我们把函数的**输入值**放在函数名字后面的括号`（）`中间：

> 所以 **f(x)** 的意思是函数叫 `"f"`，而 `"x"` 是**输入值**

函数对输入值进行的运作：

> **f(x) = x^2^** 显示函数 `"f"` 取输入值 `"x"` 的平方。

根据下面这个函数，


$$
f(x) = x^2
$$


我们假设输入为4，那么输出就是16了，所以我们可以这样


$$
f(4)=16
$$


一些注意点，**✎：**

- `"x"` 只是个位置标志符！,也就是说，你可以换成是其它符号，如q、z等什么的，而且这些符号还有个名字，叫自变量

- 函数有时没有名字，如  y = x^2^

  不过，这个函数仍然有，**✎：**

  - 输入（x）

  - 关系（取平方）
  - 输出（y）

- 「关系」：函数显示输入与输出的**关系**。"**f(4) = 16**" 就是说 4 和 16 是有关系的：4 → 16，而这个关系就是 f。举个例子就是「一棵树每年长高 20厘米」，那么树的高度和它年龄的关系可以用函数h来显示，**✎：**

  `h(年龄) = 年龄 × 20`

  所以，如果年龄是 10年，高度就是：

  `h(10) = 10 × 20 = 200厘米`

  > 输入和输出之间的关系可以用函数来表示，如树的年龄知道了，那么树的高度也就知道了，然而为啥会知道呢？因为有个函数可以描述它们之间的关系啊！
  >
  > 就像是我们俩的关系是男女朋友，然后输入一个「我爱你」，输出一个「我也爱你」

- 函数处理什么？最常见是数字，当然输入也可以是字母等其它特别的字符

- 对函数的另一个看法：把函数的输入和输出为一个 "序偶"，例如 (4,16)。这就是坐标了。函数可以被定义为序偶的**集**，而坐标的集也是函数

一些结论，**✎：**

> - 函数显示输入与输出的**关系**
>
> - 函数把一个集（**定义域**的元素联系到另一个集（陪域）的元素。
>
> - 所有的输出值（陪域里实际与定义域有关系的元素）的集叫**值域**
>
> - 特别关系：
>
>   - 包含定义域里**每个元素**，
>   - 任何输入值**只有一个输出值**（不能是一个**或**另一个输出值）
>
> - 一个输入值和它的输出值一起就叫做**序偶**
> - 所以函数也可以被视为一个**序偶的集**

抛开以上的一切内容，把函数看作是一个实现某种**功能**的工具（盒子），就像这样，**✎：**

![preview](img/02/cd7c0a4d89e853da418514d6aae7d1ab_r.jpg)

函数d就是一个盒子，将输入的x转化为输出的y

> 在我看来这就像是拿一个东西去换另一个东西（注意：只能换同一件东西），至于换成是什么，到底值不值，这就看这个函数是如何定义的了，即「这个兑换规则是怎样的」或者说「这个东西和另外一个东西之间的关系是怎样的」
>
> 回到编程，或许把function翻译成「功能」比较好
>
> ps：联想到LOL，如何补刀呢？如何让这个小兵的最后一下是由你操纵的这个英雄给终结的呢？你输入一个平A，你要想得到这个小兵的经济，那么平A和小兵的经济的关系可以用一个函数f来表示，而这个函数该如何去写呢？按照我的经验，这会分很多情况，不过我一般都是凭感觉去补刀的，所以这不会保证自己一定会得到小兵的经济，除非周边没有其它家伙在攻击敌方小兵，而是只有自己操纵的那一个英雄……
>
> 所以说一个函数写得好不好，还是很重要的……因为写得不好的话，那么结果就有一定几率不是你想要的！如果我要用一个名字形容这样的函数的话，我会叫做「过家家函数」，似乎也可以叫做「玩具函数」，总之就是简单得可以搞一下，复杂一点的就不行了……
>
> 额……函数到底是关系（映射）？还是说函数让输入和输出有了关系呢？



---

**➹：**[函数是什么](https://www.shuxuele.com/sets/function.html)

**➹：**[函数 - Wikiwand](https://www.wikiwand.com/zh-hans/%E5%87%BD%E6%95%B0)

**➹：**[你对函数的理解是什么？ - 知乎](https://www.zhihu.com/question/21301730)

**➹：**[数学和编程](http://www.yinwang.org/blog-cn/2015/07/04/math)

### ②什么是 Lambda 演算？

**➹：**[Λ - Wikiwand](https://www.wikiwand.com/zh-hans/%CE%9B)

**➹：**[λ演算 - Wikiwand](https://www.wikiwand.com/zh-hans/%CE%9B%E6%BC%94%E7%AE%97)

**➹：**[什么是 Lambda 演算？ - 知乎](https://www.zhihu.com/question/21936396)

**➹：**[认知科学家写给小白的Lambda演算 - 知乎](https://zhuanlan.zhihu.com/p/30510749)

**➹：**[Good Math/Bad Math的Lambda演算系列的中文翻译 · cgnail's weblog](http://cgnail.github.io/academic/lambda-index/)

### ③函数式编程？

**➹：**[编程的智慧](http://www.yinwang.org/blog-cn/2015/11/21/programming-philosophy)

**➹：**[编程的宗派](http://www.yinwang.org/blog-cn/2015/04/03/paradigms)

**➹：**[JavaScript 函数式编程（一） - 掘金](https://juejin.im/post/5b7014d5518825612d6441f8)

**➹：**[functional-programming-in-javascript](http://slides.com/yangzhenyu/functional-programming-in-javascript#/)‘