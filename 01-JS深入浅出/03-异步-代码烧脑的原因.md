---
typora-copy-images-to: img\03
---

# 异步 - 代码烧脑的原因

## ★总览

本次任务的第一个视频是上节课课后题的答案

### ◇同步与异步

同步：等待结果
异步：不等待结果

注意，异步常常伴随回调一起出现，但是异步不是回调，回调也不一定是异步

```javascript
// 同步的 sleep
function sleep(seconds){
    var start = new Date()
    while(new Date() - start < seconds * 1000){

    }
    return
}
console.log(1)
sleep(3)
console.log('wake up')
console.log(2)
```

![同步的sleep](img/03/Fk3uIFNUM-XyzClsAyB5MzmZzQki)

```javascript
//异步的 sleep
function sleep(seconds, fn){
    setTimeout(fn, seconds * 1000)
}
console.log(1)
sleep(3, ()=> console.log('wake up'))
console.log(2)
```

![异步的sleep](img/03/FuYkM9AJekunsdsrsmTumIUfWPg0)

可以看出，用了异步之后，JS 的空闲时间，多了许多。

但是注意，在 JS 空闲的这段时间，实际上是浏览器中的计时器在工作（很有可能是每过一段时间检查是否时间到了，具体要看 Chrome 代码）

### ◇前端经常遇到的异步

```js
document.getElementsByTagNames('img')[0].width // 宽度为 0
console.log('done')
```

```js
document.getElementsByTagNames('img')[0].onload = function(){
    console.log(this.width) // 宽度不为 0
    console.log('real done')
}
console.log('done')
```

### ◇面试题中的异步

```js
let liList = document.querySelectorAll('li')
for(var i=0; i<liList.length; i++){
    liList[i].onclick = function(){
        console.log(i)
    }
}
```

把 var i 改成 let 就可以破解：<https://zhuanlan.zhihu.com/p/28140450>

### ◇AJAX 中的异步

```js
let request = $.ajax({
  url: '.',
  async: false
})
console.log(request.responseText)
```

```js
$.ajax({
    url: '/',
    async: true,
    success: function(responseText){
        console.log(responseText)
    }
})
```

### ◇异步的形式

一般有两种方式拿到异步结果

1. 傻逼方法：轮训
2. 正规方法：回调

### ◇回调的形式

1. Node.js 的 error-first 形式

   ```js
    fs.readFile('./1.txt', (error, content)=>{
        if(error){
            // 失败
        }else{
            // 成功
        }
    })
   ```

2. jQuery 的 success / error 形式

   ```js
    $.ajax({
        url:'/xxx',
        success:()=>{},
        error: ()=>{}
    })
   ```

3. jQuery 的 done / fail / always 形式

   ```js
    $.ajax({
        url:'/xxx',
    }).done( ()=>{} ).fail( ()=>{} ).always( ()=> {})
   ```

4. Prosmise 的 then 形式

   ```js
    $.ajax({
        url:'/xxx',
    }).then( ()=>{}, ()=>{} ).then( ()=>{})
   ```

### ◇如何处理异常？

1. 如何使用多个 success 函数？
2. 在有多个成功回调的情况下，如何处理异常？

### ◇自己返回 Promise

```js
function ajax(){
    return new Promise((resolve, reject)=>{
        做事
        如果成功就调用 resolve
        如果失败就调用 reject
    })
}

var promise = ajax()
promise.then(successFn, errorFn)
```

Promise 深入阅读：<http://www.cnblogs.com/hustskyking/p/promise.html>

Promise/A+ 规范：<https://segmentfault.com/a/1190000002452115>

### ◇async / await

```js
function buyFruit(){
    return new Promise((resolve, reject)=>{
        做事
        如果成功就调用 resolve
        如果失败就调用 reject
    })
}

var promise = await ajax()
```

```js
async functon fn(){
    var result = await buyFruit()
    return result
}

var r = await fn()
console.log(r)
```

## ★上节课答案

### ◇分析题目

![1545366008044](img/03/1545366008044.png)

> 这莫非就是输入和输出，难怪老师会这样写……

### ◇如何写一个函数？

你在写一个函数的时候只需要关心两件事情：

1. 它的输入是什么鬼
2. 它的输出是什么鬼

搞清楚这个输入和输出之后，再去写这中间的逻辑！

### ◇开搞

**①根据形式，确定输入和输出：**

![1545366751365](img/03/1545366751365.png)

这个返回值的形式更addOne这个函数的形式一模一样……所以你在学函数式的时候一定要记形式，不要去管这个逻辑是怎样的额，只需要把形式给记下来就ok啦！为什么这么说呢？——因为对于函数式来说，形式是大于逻辑的，函数是有这个特点的，总之形式很重要，像柯里化整个就是一个形式变化

目前，我们知道了一个最简单的柯里化是怎么写的了！

**②简单点——实现一个只能把两个参数变成一个参数的curry函数**

> 当你没有思路的时候，就把这个东西给简化一下，所以我们不需要搞那么复杂的，只要能实现把sum函数变成addOne函数，那么我就是成功的。
>
> 总之先把这个最简单的（sum函数）给实现了，然后再去搞这个（abc函数）复杂的！

![1545368057128](img/03/1545368057128.png)

一旦调了这个return出去的函数，那么我们就call一下这个fn！

这个curry函数只能实现把sum变成addOne的这么一个柯里化

![1545368516483](img/03/1545368516483.png)

可以见到，addOne实际上是curry这个函数所return出来的函数，这个函数会接受一个参数p2，当我们调用这个函数，那么是上就会去调用sum函数！我们之前用了curry函数固定了sum函数的一个参数，之后在根据你调用addOne函数所传的参数（你传什么就是什么），确定最终的输出结果

这个curry函数做到了——把一个接受两个参数的函数变成固定一个参数接受另一个参数的函数！

一些问题：

1. 我们题目要求的abc函数有3个参数，而这里的sum只有2个参数
2. 可以不传参数1，即固定什么值由用户指定的！而不是交给这个curry函数！

接下来干啥？

如果不传这个1——形式是这样的：

```js
var fn2 = curry(sum)
var addOne = fn2(1)
fn(1)(2)
//本来的形式：
sum(2,3) //5
//通过柯里化这个sum函数之后，现在调用sum函数的形式：
fn2(2)(3)
//注意：不要去管形式转化的逻辑是怎样的，目前，你只需要关注形式是怎样的就可以了！
```

也就是说你传什么就固定什么参数，如你先传个1然后再传个2，就是你先固定一个1，相当于是addOne函数，然后再调用sum函数！

确定形式：

![1545370245182](img/03/1545370245182.png)

我们在curry sum函数的时候不需要传任何参数，即柯里化这个sum函数把固定参数这一步给消掉了！，总之对curry函数只需要传sum函数即可！其它参数不需要传！至于什么时候传呢？——后面传，即对curry函数所返回的新函数传即可，如fn1……第一次传什么就把sum函数的x形参固定为什么……

接下要考虑什么呢？——怎么能让curry函数接受有3个参数的fn呢？

很简单，再加个return就好了，与此同时你会了解到惰性求值是什么鬼？即不传够三个参数你会无法调用那个fn函数的！

![1545448079774](img/03/1545448079774.png)

或许你会问这有点多余、有点无聊！因为我直接 `sum(1,2,3)`就好了，即一开始就可以传到位了，为啥还要柯里化sum后再调用呢？

但是有一种情况就是「有没有可能你一开始就不知道传给sum函数有哪些参数？或者说你需要异步请求后才知道有哪些参数」——所以柯里化是能给你一次机会——让你把两次值用不同的时间来传。如sum函数的这3个参数需要从不同的服务器上请求来的数据，然后数据到位了，就把它们混到一起，才调用sum函数。而用柯利化呢？——拿到什么就传什么，那什么时候凑齐了就什么时候有结果……

可见，这就是使用了柯利化的好处啦！

那如果接受4个参数呢？咋办？

难道要再加个return？显然不能继续这样干了，因为我们无法确定fn到底有多少个参数……

好话说，有咩有一个属性标志着某个函数要接受几个参数？——有的，length属性，即函数接受几个参数可以length得到：

![1545449248714](img/03/1545449248714.png)

这就给我们一个启发了呀！——我们要return几次函数不就是看它要接受几个参数吗？

> 也就是说return几个函数是动态变化的咯！

总之，return（最后那个return调用fn不算）的嵌套层数就是它的length。

所以终极curry的思路是怎么写的呢？——每return一次就记一下数就告诉curry「我已经return过一次了，然后下次你就只需要return两次了」

![1545450897740](img/03/1545450897740.png)

总之通过一个length再加一个计数器就能搞定这个事了！

**➹：**[JavaScript函数式编程--柯里化(curry) - Jin](https://jinyy.app/article/js-func-curry/)

```js
function curry(func , fixedParams){
    if ( !Array.isArray(fixedParams) ) { fixedParams = [ ] } //防止fixedParams一开始是undefined，为此无法使用数组的cancat方法
    return function(){
        let newParams = Array.prototype.slice.call(arguments); // 新传的所有参数
        if ( (fixedParams.length+newParams.length) < func.length ) {
            return curry(func , fixedParams.concat(newParams));
        }else{
            return func.apply(undefined, fixedParams.concat(newParams));
        }
    };
}
```

分析：

> 当传入的参数个数没有到达`func`函数要求的参数个数的时候一直返回柯里化函数。
> 只有参数满足`func`函数的个数的时候才通过`apply`执行`func`函数。

![1545460844583](img/03/1545460844583.png)

## ★目录

异步是一些人之所以学不会JS的主要原因！总之你学不会JS，那是因为你不知道什么是异步！

这节课讲什么？

- 什么是同步？什么是异步？
- 前端经常会遇到的异步代码
- 面试题
- AJAX中的异步
- 异步主要获取结果的形式
- 回调是怎么用的
- 如何处理异步中的异常
- 什么是Promise
- 讲解一下async和await这个两个关键字

## ★同步与异步

> **➹：**[怎样理解阻塞非阻塞与同步异步的区别？ - 知乎](https://www.zhihu.com/question/19732473)
>
> 为啥同步和异步会涉及到I/O呢？——似乎涉及到网络请求等……
>
> 同步与异步的概念在JS中会不会有点不一样？

### ◇区别

简单来说，同步就是等待结果，而异步则是不等结果！形象一点来说就是同步是个很有耐心的一个人，而异步则是一个很急躁的、没有耐心的人！

#### 用代码来说明

```javascript
// 同步的 sleep
function sleep(seconds){
    var start = new Date()
    while(new Date() - start < seconds * 1000){

    }
    return
}
console.log(1)
sleep(3)
console.log('wake up')
console.log(2)
```

解释一波：

这里有个sleep函数，它什么都咩有做，只是等待几秒钟而已……

运行结果，先log个1，然后睡3s，接着再醒来，最后输出2

所以打印顺序为1→☞停3s→☞wake up→☞2

这个过程其实很符合我们人类的直觉，既然要让程序停3s，那就停3s呗……可是JavaScript不支持啊！总不能说V8老哥不要解释代码了，等3s后你在解释第11行代码吧！所以如何模拟出停3秒呢？——写一个执行3s但无意义的操作即可！简单来说，就是这3s之内，v8还在执行代码……只是做一些无意义的操作而已！唯有这样才能按顺序执行的……

在这个sleep函数中，我没有想到的是`new Date()`做计算的话，会得到毫秒数！还有那个循环判断等于3000ms也行……

接下来通过控制台，可视化3s这段时间做了什么：

1. 打开控制台
2. 切换到Performance，然后按一下ESC，就会出现Console
3. 把代码复制到Console中去，不要按回车
4. 点击左上角的Record，即记录一下我们的CPU，然后回车运行代码！

5. 运行结束后，就点击Stop，表示停止记录……

![1546692158321](img/03/1546692158321.png)

你可以看到这橙色部分基本连成一片了，所以sleep这个函数就好像让JS引擎不停地看表（看循环的判断条件……），直到走了3s钟才结束……

那么这3s钟之内看 了多少次表呢？——这个得看你的CPU有多强了，你CPU越强，看的时间次数越多！当然还得看一些软件设置，总之具体有多少次是不知道的！至少几十万次吧……

所以所谓的同步就是，`console.log('wake up')` 要等 `sleep(3)` 执行完毕后才会执行自己！

那么可以不等吗？可以不等，那就是异步啦！

```javascript
//异步的 sleep
function sleep(seconds, fn){
    setTimeout(fn, seconds * 1000)
}
console.log(1)
sleep(3, ()=> console.log('wake up'))
console.log(2)
```

这个sleep除了接收一个秒数以外，还接收一个回调！

我们把代码运行一下，**✎：**

![1546758374905](img/03/1546758374905.png)

发现，`wake up`是最后才打印的！即 `console.log(2)`并咩有等 `sleep(3, ()=> console.log('wake up'))`的执行完……

为什么不会等它执行完呢？我想来看一看sleep这个函数做了什么吧！

1. 输入：秒数、回调fn

2. 函数体：设置一个闹钟，这个闹钟会在3000ms之后调用这个fn。而在这3000ms之内JS啥也没做，之前是不停地看表，而这次则是到了时间，就由浏览器调用fn，调用fn这件事情也不是JS做的……是浏览器做的！总之

   `setTimeout(fn, seconds * 1000)`的意思是说「浏览器同志请在3秒钟之后调用fn」，毕竟这个setTimeout是浏览器提供的API，所以浏览器会去负责调用这个fn，而fn里面的才是JS的代码！

   我们**不需要等fn被调用**，直接就开始执行下一句了……此时JS是很闲的，就想去睡觉一样，接着3s后就醒来了……

所以异步和同步的区别就是，下一句不会等上一句代码执行完毕……

我们可以再次查看JavaScript的执行情况：

![1546758751206](img/03/1546758751206.png)

> 照理说会有一段时间不连贯才对的！……
>
> 额我看到了后面，原来是我肉眼没有观测到的原因：

![1546760371176](img/03/1546760371176.png)

### ◇时序图

画出它们俩的运行过程……

一般异步的过程都用时序图画出来！

#### 同步

![1546761222490](img/03/1546761222490.png)

#### 异步

![1546763632251](img/03/1546763632251.png)



定完闹钟后就马上执行 `console.log(2)` ，这是为什么呢？因为v8引擎很闲哈！总不能傻傻地等着吧！

之所以我们可以实现异步，那是因为我们把定时这件事交给浏览器做了！这样一来JS引擎执行的时间就变少了！毕竟JS引擎处于活跃状态的话，是会阻塞浏览器的，即用户无法实时地与页面交互了！

> 其实说白了就是，一旦call stack中还有代码需要被JS引擎执行的话，那么这是会阻塞浏览器渲染的……毕竟有个渲染队列哈！

浏览器在定好闹钟之后，会定期地去看时间到了没有，一旦到了，它就会通知JS引擎去执行一下你刚刚给我的fn！

时序图是一个非常重要的用于理解异步概念的图！

### ◇小结

- 同步会等待sleep这个函数执行完毕，而异步则不会等待，直接跳到下一句！

## ★异步面试题

> 举3个异步的例子！

### ◇图片？获取它的宽度？

```js
document.getElementsByTagNames('img')[0].width // 宽度为 0
console.log('done')
```

```js
document.getElementsByTagNames('img')[0].onload = function(){
    console.log(this.width) // 宽度不为 0
    console.log('real done')
}
console.log('done')
```

- 当你分析问题不清楚的时候，就用时序图吧！

  ![1546773613059](img/03/1546773613059.png)

- 回调有多种形式，之前我们所讲的那种是作为参数的形式，那是最常见的，而用onload事件这种呢？则是另一种回调！总之我们无法确切知道图片什么时候加载成功，或许10ms、50ms……所以只能通过事件去做了……

---

![1546773790364](img/03/1546773790364.png)

所以异步想要真正拿到结果，要么就去监听一个事件，即你异步操作成功了，就告诉我……毕竟你的成功时间是不可预测的！所以我们就先挂一个函数到你的身上……即挂一个函数到onload身上，等你加载成功后，你就调一下这个onload即可！

以上就是前端遇到的第一种异步，即图片加载是需要时间的，还有一种就是面试的时候会经常问到的！

### ◇面试题中的异步

#### var？for循环……

![1546778976641](img/03/1546778976641.png)

浏览器没有等图中用圈圈	圈住的那个代码执行，直接就进入到一下个循环……总之事件是异步的……

时序图分析：

![1546779051499](img/03/1546779051499.png)

如何解决这个问题？——不要用var，用let就好了！

如果不理解let，那么就看看这篇文章：

**➹：**[我用了两个月的时间才理解 let - 方应杭的个人网站](https://fangyinghang.com/2017/let-in-js/)

#### let？for循环……

![1546779644834](img/03/1546779644834.png)

第一次循环给个i1，第二次循环给个i2……这是let做到的！总之i1等这些是不会变的……只有外面那个i才会变！而那6个分身不会变！整体来看改为let之后，从1个i变为了6个i，即多了5个i！

总之你可以直接记住结论，即把var改为let就好了！

时序图的话：

![1546779800909](img/03/1546779800909.png)

### ◇AJAX中的异步

后端程序员转前端的程序员，尤其喜欢把AJAX变为同步的，而且你会发现同步的AJAX这很奇葩啊！因为AJAX的A是异步的意思！……总之AJAX必须是异步的，况且这种同步的AJAX早就快被废除了！**✎：**

```js
let request = $.ajax({
  url: '.',
  async: false
})
console.log(request.responseText)
```

这个 `.`表示向当前页面的url请求，请求结束后才log出结果！

时序图：

![1546780877089](img/03/1546780877089.png)

用户点击了按钮，浏览器也不会响应它的动作！你可以通过这段代码测试，且在网速很慢的情况，你会发现无法选中页面中的文本！

![1546783856176](img/03/1546783856176.png)

**➹：** [demo](http://js.jirengu.com/tedinukoko/1/edit)

总之，这是一种非常垃圾的写法！所以你把异步变成同步的话，那么在你请求的过程中，整个页面什么东西都不能动，就像死了一样，但是如果你改成异步的话：

![1546783936645](img/03/1546783936645.png)

可见这就是异步的好处，即在请求结束前，浏览器同样可以响应用户所做的一些事件！而不需要等着你这个网络请求的响应返回……

接下来，来讲一下是如何拿到异步的结果的！

之前那个图片我们是在onload事件中拿到结果的，而且你不要痴心妄想可以在其它地方拿到！

还有onclick也是，当浏览器调用所赋给onclick的函数时，就会传一个东西给这个回调！

还有一种就是那个success函数！

而同步不需要什么技巧，直接就可以拿到了，**✎：**

```js
let request = $.ajax({
  url: '.',
  async: false
})
console.log(request.responseText)
```

接着把异步的结果赋值给request即可拿到，不需要什么特殊的技巧！但是异步呢？需要一些技巧（这些技巧不是所有人都知道的！）才能拿到，如onload、success……

## ★回调的形式

### ◇如何拿到异步代码的结果













































---

## ★总结

- 把大问题拆解成小问题，根据大问题提供的方向扩展小问题，为此小问题逐渐演化成大问题，最终的结果就是把大问题给解决了，而这个过程是不断地添加问题和解决问题，有种「极限」的调调（联想到求导）……把大问题解决就像是你不想添加新问题或者说是你找不到新问题可以添加进去……

- 当你看视频学习的时候，尤其是讲解某些知识点，你最好先预习一遍，看一下资料，然后试着尝试自己先讲解一波，最后根据视频所讲的与自己所讲的进行一个比较，你在自学一遍的过程中，所遇到的不会，你就在视频找寻答案；对有些东西的理解是否准确或者说是不是还有更好的理解姿势，你都可以去视频中找寻答案！

  总之，基于每个人知识面的不同，所以对同一样的东西理解可能会千奇百怪，不管怎样，只要能解决问题就好了！至于解决问题的姿势漂不漂亮，还需要积累……

- 额，本来是腰腿有点疼，可是心无杂念（专注于写总结），坐姿比较正确，结果一站起来好像没有那么疼了……当然专注于打LOL也是如此……

- 练习题——写一个curry函数：关键在于判断所传参数个数是否凑齐了！凑齐了就调用fn啦，如果没凑齐就继续柯里化咯！





---

## ★Q&A

### ①形式大于内容？

我本来想要搜索的是「形式大于逻辑」，结果出现「形式大于内容，逻辑大于情感」……

**➹：**[演讲或讲课过程中，形式大于内容？ - 知乎](https://zhuanlan.zhihu.com/p/20853039)

**➹：**[《一代宗师》：概念先行，形式大于内容-影视评论-论坛_天涯社区](http://bbs.tianya.cn/post-filmtv-378464-1.shtml)

### ②UML？

常用的 UML 图可分静（态）图、动（态）图两类，静态图主要描绘软件的静态结构，而动态图主要描绘软件的动态行为。

常用 UML 动态图（5 个）：

用例图，活动图，状态机图，序列图，通信图。

常用 UML 静态图（4 个）：

类图，包图，部署图，构件图。

以上这 9 种图是从 UML 1.x 开始就有的，因而很基础，建议初学者先掌握这些图。

不常用的 UML 图大多是 UML 2.x 后来添加的，有 5 个：

对象图（1.x 起）、组成结构图、扩集图、交互概览图、时序图。

**➹：**[时序图 - Wikiwand](https://www.wikiwand.com/zh-hans/%E6%97%B6%E5%BA%8F%E5%9B%BE)

**➹：**[顺序图的语法和功能](http://plantuml.com/sequence-diagram)

**➹：**[在软件开发过程中，有哪些UML图是比较常用的？ - 知乎](https://www.zhihu.com/question/22253854)

**➹：**[UML 还有用吗？ - 知乎](https://www.zhihu.com/question/23569835)

**➹：**[UML实践详细经典教程----用例图、顺序图、状态图、类图、包图、协作图](http://www.uml.org.cn/oobject/201609092.asp)

**➹：**[时序图、流程图、状态图、协作图之间的区别 - rosekin的专栏 - CSDN博客](https://blog.csdn.net/rosekin/article/details/14519277)

**➹：**[快速学习时序图：时序图简介、画法及实例 -人人都是产品经理](http://www.woshipm.com/ucd/607593.html)

### ③performance？

**➹：**[全新Chrome Devtool Performance使用指南 - Nic's Utopia](https://nicholaslee119.github.io/2017/10/04/Chrome-Devtool-Performance%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/)

### ④V8到底是解释代码还是执行代码？

你要知道编程语言分为编译型语言和解释型语言两类，编译型语言在执行之前要先进行完全编译，而解释型语言一边编译一边执行，很明显解释型语言的执行速度是慢于编译型语言的，而JavaScript就是一种解释型脚本语言，支持动态类型、弱类型、基于原型的语言，内置支持类型……

V8确实是在执行代码，即把JavaScript代码编译成机器码，为此，好让CPU真正地去执行代码！

目前JS引擎的执行过程为：

源代码-→抽象语法树-→字节码-→JIT-→本地代码(V8引擎没有中间字节码)。

**➹：**[认识 V8 引擎 - 知乎](https://zhuanlan.zhihu.com/p/27628685)

