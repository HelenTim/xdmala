---
typora-copy-images-to: img\03
---

# 异步 - 代码烧脑的原因

## ★总览

本次任务的第一个视频是上节课课后题的答案

### ◇ 同步与异步

同步：等待结果
异步：不等待结果

注意，异步常常伴随回调一起出现，但是异步不是回调，回调也不一定是异步

```javascript
// 同步的 sleep
function sleep(seconds){
    var start = new Date()
    while(new Date() - start < seconds * 1000){

    }
    return
}
console.log(1)
sleep(3)
console.log('wake up')
console.log(2)
```

![同步的sleep](img/03/Fk3uIFNUM-XyzClsAyB5MzmZzQki)

```javascript
//异步的 sleep
function sleep(seconds, fn){
    setTimeout(fn, seconds * 1000)
}
console.log(1)
sleep(3, ()=> console.log('wake up'))
console.log(2)
```

![异步的sleep](img/03/FuYkM9AJekunsdsrsmTumIUfWPg0)

可以看出，用了异步之后，JS 的空闲时间，多了许多。

但是注意，在 JS 空闲的这段时间，实际上是浏览器中的计时器在工作（很有可能是每过一段时间检查是否时间到了，具体要看 Chrome 代码）

### ◇前端经常遇到的异步

```js
document.getElementsByTagNames('img')[0].width // 宽度为 0
console.log('done')
```

```js
document.getElementsByTagNames('img')[0].onload = function(){
    console.log(this.width) // 宽度不为 0
    console.log('real done')
}
console.log('done')
```

### ◇面试题中的异步

```js
let liList = document.querySelectorAll('li')
for(var i=0; i<liList.length; i++){
    liList[i].onclick = function(){
        console.log(i)
    }
}
```

把 var i 改成 let 就可以破解：<https://zhuanlan.zhihu.com/p/28140450>

### ◇AJAX 中的异步

```js
let request = $.ajax({
  url: '.',
  async: false
})
console.log(request.responseText)
```

```js
$.ajax({
    url: '/',
    async: true,
    success: function(responseText){
        console.log(responseText)
    }
})
```

### ◇异步的形式

一般有两种方式拿到异步结果

1. 傻逼方法：轮训
2. 正规方法：回调

### ◇回调的形式

1. Node.js 的 error-first 形式

   ```js
    fs.readFile('./1.txt', (error, content)=>{
        if(error){
            // 失败
        }else{
            // 成功
        }
    })
   ```

2. jQuery 的 success / error 形式

   ```js
    $.ajax({
        url:'/xxx',
        success:()=>{},
        error: ()=>{}
    })
   ```

3. jQuery 的 done / fail / always 形式

   ```js
    $.ajax({
        url:'/xxx',
    }).done( ()=>{} ).fail( ()=>{} ).always( ()=> {})
   ```

4. Prosmise 的 then 形式

   ```js
    $.ajax({
        url:'/xxx',
    }).then( ()=>{}, ()=>{} ).then( ()=>{})
   ```

### ◇如何处理异常？

1. 如何使用多个 success 函数？
2. 在有多个成功回调的情况下，如何处理异常？

### ◇自己返回 Promise

```js
function ajax(){
    return new Promise((resolve, reject)=>{
        做事
        如果成功就调用 resolve
        如果失败就调用 reject
    })
}

var promise = ajax()
promise.then(successFn, errorFn)
```

Promise 深入阅读：<http://www.cnblogs.com/hustskyking/p/promise.html>

Promise/A+ 规范：<https://segmentfault.com/a/1190000002452115>

### ◇async / await

```js
function buyFruit(){
    return new Promise((resolve, reject)=>{
        做事
        如果成功就调用 resolve
        如果失败就调用 reject
    })
}

var promise = await ajax()
```

```js
async functon fn(){
    var result = await buyFruit()
    return result
}

var r = await fn()
console.log(r)
```

