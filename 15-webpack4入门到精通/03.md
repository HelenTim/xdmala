# 开发模式深入、代码分割、结果文件阅读

> 视频时长115分钟，所以我得在345分钟，即5.75个小时之内把它看完！（14个番茄）

## ★模式区分

### ◇为什么要分模式

因为在不同的场景下可能需要不同的配置，所以需要区分环境。

比如:

- 开发阶段：会额外用到一些调试功能，但为了快速打包和调试，可能不会使用压缩、tree-shaking、编译之类的功能。
  
- 上线阶段：生产模式下，为减少打包体积，必须使用压缩、tree-shaking、编译等功能，但不需要eslint等帮助开发调试的功能。

话说，就只有两种模式吗？即只有生产模式和开发模式这两种？

并不是，大型点的项目还有测试模式等，除此之外，模式并不是webpack独有的概念，举例来说，同一份代码，在公司开发是一种模式，在家里开发也是一种模式，同样，在星巴克里边找个位置坐着也是一种开发模式！

**➹：**[前端架构设计3：测试核心 - axl234 - 博客园](https://www.cnblogs.com/axl234/p/9430277.html)

### ◇如何指定模式

有两种方式指定：

1）`webpack --env envname`：webpack会拿到envname这个值！envname可以是任意值，如生成模式「production」、在家开发模式「home」等

话说，我们的webpack配置文件如何才能拿到「envmae」这个值？

1. 把 `module.exports = {}` 改为 `module.exports = env => {}`，env就是webpack拿到的环境变量
2. 需要引入webpack-merge

做法：

创建3个文件，然后给上相应的配置即可：

```
webpack.common.js //通用配置，如处理js、css、html、图片等，总之什么地方都要用到的就抽离出来
webpack.dev.js 
webpack.pro.js
```

一个坑：

> 在开发模式下，如果你把CSS提取为单独的文件，那么会使得CSS无法live-reload和热更新，所以在开发模式就不能单独提取CSS文件了！

一个思想：

> 一定要把webpack配置文件当作是一个程序，而不是简单的一个填充数据的配置文件。因此对于我们的模式区分来说，完全可以用一个函数来搞！

合并规则：

> 根据不同的模式，往common配置里边添加 dev or pro，假如dev有处理js的，common也有处理js的，那么dev下的js配置，就会顶掉common下的js配置。总之一个新的配置，即合并出来的配置就是，common+dev or pro!

开发模式和生产模式下分别有什么？

开发模式：

- HotModuleReplacementPlugin（热更新）
- NamedModulesPlugin（在热加载时直接返回更新文件名，而不是文件的id，与HMR相关）

**➹：**[webpack插件之NamedModulesPlugin - 简书](https://www.jianshu.com/p/8499842defbe)

生产模式：

- 压缩（webpack4里边指定mode即可，如果不这样做，可以把 `optimization.minimize` 指定为true即可压缩）
- 代码分割等

配置scripts：

``` json
{
  "build": "webpack --env production --config webpack.common.js",
  "dev": "webpack-dev-server --env development --config webpack.common.js --open"
}
```

> 指定webpack打包的配置文件为 「webpack.common.js」，然后webpack就会读取该配置文件返回对象，而这个对象会根据「production」or「development」会有所不同，即会生成一个最终配置哈！而这也是 `npm run build` 和 `npm run dev` 的这么一个模式区分原理哈！

### ◇Webpack-dev-server常用配置

> 这是我们开发项目的核心配置！

开启开发模式，使用的是 `webpack-dev-server`（需要安装）来执行打包，而不是生产模式的`webpack`。

常用配置：

- inline：服务的开启模式，默认为true，因此一般删掉这个属性，如果显示设置为false，那么打开页面的时候，就会页面地址就会这样：`localhost:9001/webpack-dev-server`，总之为false，会把打包的进度条显示到页面，而不是console控制台里边！

- port：代理接口，把我们启动的服务开在哪个端口下

- historyApiFallback：路径重定向
- Hot：热更新
- lazy：懒编译
- overlay：错误遮罩
- proxy：代理请求

详解，即展示每个配置项会有什么效果：

1）热更新：

> 所谓热更新指的是无刷新更新页面，而不是修改代码保存，页面自动刷新！

有刷新和无刷新的区别：

有刷新即页面里边的状态会被重置，如定时器和计时器等，说白了所有的程序都会开始重新运行

而无刷新则是在保证页面的状态下能够更新我们的所更改的代码（热更新）

而自动的刷新得更新页面，则是「live-reload」

如果不配置热更新，那么默认情况下就是live-reload，即你修改个css，js等保存后，都会刷新页面

> 更改业务代码不需要重新打包，但如果更改了webpack配置，那就得重新打包！

开启热更新做法：

1. 只使用HMR插件是不行的，你还得配置，如：
2. 设置hot为true
3. 设置hotOnly为true，表示只允许热更新！



### ◇Source-map


### ◇自己手动搭建


## ★代码分割

### ◇多页面应用

### ◇单页面应用

### ◇所以一般这么打包

### ◇版本差异

### ◇压缩













