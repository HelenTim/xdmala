# 基础篇

## ★TPR

**1、在Node.js里边，如何去解析一个绝对路径？**

很简单，使用Node.js 的核心模块path即可，注意它是内置模块，不需要我们去安装

做法如下：

1. require path 模块
2. `path.resolve('./xxx.js')`，resolve是解析之意，可以把相对路径解析成绝对路径

测试：

``` js
let path = require('path')
console.log(path.resolve('dist')) //g:\git-2019\zf-webpack-demo\dist
```

不过，我们一般会加上个 `__dirname`参数，表示「在当前目录下，产生个dist目录」

``` js
path.resolve(__dirname, 'dist') //结果同上
```






## ★webpack基础配置

<mark>1）初始化项目，webpack本地安装</mark>

``` bash
mkdir zf-webpack-demo
cd zf-webpack-demo
yarn init -y
yarn add -D webpack webpack-cli
```

> -D 表示的是开发依赖，项目上线的时候不需要！

<mark>2）webpack可以进行0配置</mark>

> 只要是0配置，那么这就意味着它的配置肯定是很弱的！

我们知道webpack是打包工具，即它可以把我们的源码进行打包，然后打包出输出后的结果

而且它默认识别的是所谓的「JS模块」

它会从入口文件开始，然后把所有的JS 进行打包，最后进行一个输出！

webpack需要一个被打包的目录，而这一般都会是 `src`目录，因为这是源码存放的地方

做法：

1、创建 `src/index.js` 文件

2、对index.js这个文件进行打包，直接 `npx webpack`即可

> `npx` 是 5.2版本之后npm提供的命令，它可以执行.bin下的可执行文件。当然，你也可以配置 `scripts`脚本！

`npx webpack`这个操作默认会去找 `node_modules/.bin/webpack.cmd`：

``` bash
@IF EXIST "%~dp0\node.exe" (
  "%~dp0\node.exe"  "%~dp0\..\webpack\bin\webpack.js" %*
) ELSE (
  @SETLOCAL
  @SET PATHEXT=%PATHEXT:;.JS;=;%
  node  "%~dp0\..\webpack\bin\webpack.js" %*
)
```

该文件里边有个判断，如果当前目录下有node.exe，那么就会用到前这个bin目录下的node.exe，来执行webpack.js这个文件

显然，bin目录咩有这个node.exe，于是就走到了else里边的代码：

![node执行webpack.js](assets/img/2019-12-29-19-51-28.png)

可见，webpack4叫我们去安装webpack-cli

而这就是webpack和webpack-cli这两个模块之间的关系啦！

执行结果：

![0配置的执行结果](assets/img/2019-12-30-00-13-16.png)

> 图中的标注第二点标注有错误，是node执行webpack.js

在node执行webpack.js的过程中，内部会调用webpack-cli解析用户参数进行打包。而且默认会以 `src/index.js`作为入口文件。

如果你把index.js的名字改为app.js，那么执行 `npx webpack`，就会报这样的错误：

```
ERROR in Entry module not found: Error: Can't resolve './src' in 'G:\git-2019\zf-webpack-demo'
```

言归正传，我们可以看到打包出来的main.js是压缩过后的结果，而这是因为webpack它具有优化的功能，即可以把打包的文件进行优化产出！

注意，打包出来的运行main.js是可以直接运行的，结果跟没打包之前的index.js一样，这一点你可以通过「Code Runner」这个插件来测试一下

话说，我们只写了这样一行代码：

``` js
console.log('hello webpack!')
```

可是打包出来的main.js却有一大串代码，而这是为什么呢？

我们知道webpack的功能就是打包，而它默认的功能就是支持我们的js的模块化

既然说到模块化，那么这也就意味着我们可以在js文件里边写一些模块化代码，如CommonJS 规范require语法……

可我们知道遵循CommonJS 规范这样的语法，在我们浏览器里边是不能跑的，但是经过webpack打包后所产出的文件，是可以在浏览器里边跑的！

总之，webpack帮我们实现了这么一个功能：

可以帮我们去解析js文件里边的模块，并且可以找到当前js文件所依赖的模块，然后把这些模块打包成一个文件，而且还帮助我们解决了浏览器不支持require的问题，即相当于webpack它自己实现了一套模块化机制！

之前，我们说到0配置的webpack，打包能力是非常弱的，即：

1. 入口文件必须在src目录下，且叫index.js
2. 打包出来的目录叫dist目录，而且旗下有个结果文件叫main.js

而目前，我们希望更改这个dist目录，即不想把结果文件输出到这个dist目录里边去

<mark>3）手动配置webpack</mark>

之前打包的时候，终端出现过这样的警告：

```
WARNING in configuration
The 'mode' option has not been set, webpack will fallback to 'production' for this value. Set 'mode' option to 'development' or 'production' to enable defaults for each environment.
You can also set it to 'none' to disable any default behavior. Learn more: https://webpack.js.org/configuration/mode/
```

这句话的意思是说「默认的打包模式是生产模式，而生产模式意味着会优化了你的代码，如压缩体积、tree shaking……」

做法：

1、默认配置文件的名字是「webpack.config.js」

2、配置参数有mode、entry、output

话说「webpack.config.js」这个名字改么？

是可以改的！

可为啥要叫「webpack.config.js」这个名字呢？

1. node执行webpack包里边的webpack.js
2. webpack.js里边默认会调用webpack-cli
3. webpack-cli里边有个模块用于解析导出的参数对象，即那个有mode，entry，output的对象

![webpack.config的由来](assets/img/2019-12-31-02-09-41.png)

如果要强制指定webpack的配置文件，直接 `npx webpack --config xxx.js`即可

## ★webpack打包出的文件解析

## ★HTML插件

## ★样式处理（1）


## ★样式处理（2）

## ★转化es6语法

## ★处理js语法及校验

## 全局变量引入问题

## 图片处理

## 打包文件分类




