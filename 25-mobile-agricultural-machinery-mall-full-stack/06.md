# 06-用户注册

> 这次课的内容比较复杂，因为我们要打通前端、后端、数据库这三部分

## ★注册页面编写

- van-tabs
- van-cell-group
- van-field

> 完成注册功能，先从界面写起

1）登录 & 注册

vant -> Tab、Tabs -> 点击登录就切换到登录界面，同理，注册也是如此

由于我们都需要输入用户名和密码，所以我们需要搞个表单组件

2）表单

van-cell-group：

- CellGroup
- Field

细节：

- v-model：提交表单数据，数据到在vm的data里边
- required：必填项，label左侧多了红色`*`
- clearable：输入东西后，会在输入框的右侧多了个 `x` 按钮
- 密码可不是明文的
- 加个button：用于登录或注册

3）注册功能

流程：

用户输入用户名好密码 -> 点击注册按钮 -> 获取用户填的数据 -> 由前端把这两个值发送到后端 -> 后端接收数据 -> 校验、加密 -> 存入到数据库

发送ajax请求：

- 点击 -> `@click` -> registerHandler
- axios -> 提交数据到后端，然后插入数据 -> 所以用post方法，而不是get方法 -> url选择 -> 创建一个真实的后端项目来处理 -> 配置统一接口

至此，前端部分就已经完成了，接下来，来搞后端部分！

## ★后端项目——koa2

- 新建项目 shop_server
- npm init
- npm install koa --save
- node index.js

1）如何写后端代码？

前言：

我们是前后端分离的，即前端是一个项目，后端也是一个项目

前后端通信传值等操作，都是通过axios来完成的！

开搞：

1. 创建一个叫 `shop_server`的项目
2. `cd shop_server`
3. `yarn init -y`
4. `yarn add koa`
5. `touch index.js`
6. am-shop是前端项目，shop_server是后端项目 -> 前后端分离

> 为啥 `const app = new Koa()`要叫app呢？——按照我的猜测，这就是后端应用之意！

## ★MongoDB

- 安装MongoDB
- 数据库管理工具Robo 3T：<https://robomongo.org/>

1）环境启动

1. `mongod`
2. `mongo`

2）图形化界面

之前，我们学习MongoDB的时候，都是在控制台里边操作的，其实MongoDB它有对应的数据库管理工具，即有图形化界面的，类似于我们用vue-cli创建项目时选择用图形化界面创建一样……

3）安装Robo 3T

下载：

![下载](assets/img/2020-03-03-19-50-57.png)

安装：

可自定义安装到非C盘

4）使用Robo 3T

创建用户：

![Create](assets/img/2020-03-03-19-58-35.png)

结果：

![localhost](assets/img/2020-03-03-20-00-18.png)

选中localhost，然后点击「Connect」:

![界面](assets/img/2020-03-03-20-02-10.png)

通过这个图形界面，我们可以直观的查到有哪些数据库，有哪些集合，有哪些document，有哪些Field


至此，前端项目、后端项目、数据库都准备好了，那么接下来就是开发了……

## ★mongoose

- mongoose：Node和MongoDB数据通讯的数据建模库
- npm install mongoose --save
- 连接数据库 init.js
- schema 定义数据模型并引入
- npm install glob --save

- MVC：Model（模型）、View（视图）、Controller（控制器）

1）什么是mongoose？

它其实是后端的一种技术，即「Node和MongoDB数据通讯的数据建模库」

说白了，它就是完成Node和MongoDB数据库的连接，起到纽带、桥梁作用！

2）使用mongoose？

1. `yarn add mongoose`
2. index.js -> 对应的都是服务操作
3. 单独新建个init.js -> 表示初始化 -> 作用初始化我们的mongoose
4. init.js -> 引入mongoose -> 连接数据库 -> 数据库服务器是ip地址的 -> 不写端口号，默认就是那个**27017** -> `'mongodb://localhost/shop'` -> 如果没有shop这个数据库，会自动创建 -> 连接数据库，需要暴露出去
5. 数据库可能会连接成功，也可能会连接失败，所以mongoose提供了一些监听事件，如监听连接失败后，要做什么 -> 在一个完整的大型项目里边，可以搞一个计数器，当因为某种原因服务器宕掉了，连接3次都无法连接成功，那么这时就不要一直连了，而是给用户抛出提示「数据库连接失败哈，你得找人修一修、看一看」，有了这样提示，显然会更友好一些 -> 总之，你可以做个计数器来表示连接次数
6. 数据库连接发生错误了，所以我们需要监听 `error`
7. 监听连接成功时，应该提示一下说「连接成功了」

mongoose提供了一些API，让我们可以用JS语法来连接MongoDB数据库！

3）如何把init.js引入到index.js里边去？

``` js
// 还有引入其它东西，所以就用了解构语法了
const { connect } = require('./init.js');
connect()
```
4）schema 定义数据模型并引入

1、什么叫定义数据模型？

这里边会讲到一个很重要的概念，那就是MVC啦！

MVC是一种模式

话说啥叫模式？

- 模式，在物体或事件上，产生的一种**规律变化**与**自我重复**的样式之过程
- 在模式之中，某些固定的元素不断以**可预测**的方式周期性重现
- 最基本而常见的模式，称为**密铺**，具备**重复性**以及**周期性**两大特征
- **找寻出固定模式**是人类基本的认知功能之一

话说啥叫认知？

> 认知是人脑接受外界信息，经过加工处理，转换成内在的心理活动，从而**获取知识**或**应用知识**的过程。它包括记忆、语言、视空间、执行、计算和理解判断等方面。

题外话：

> [认知障碍](https://baike.baidu.com/item/%E8%AE%A4%E7%9F%A5%E5%8A%9F%E8%83%BD%E9%9A%9C%E7%A2%8D/15769094)是指上述几项认知功能中的一项或多项受损，并影响个体的日常或社会能力，当上述认知域有2项或以上受累，并影响个体的日常或社会能力时，可诊断为痴呆。

所以说，MVC这所以被称之为模式，是因为它是**固定模式**，并具有**重复性**，即**很多后端项目的代码书写都是用MVC这个模式来搞的！**

> 为啥熟能生巧？——因为找规律是我们基本的认知能力之一哈！

MVC：

- M -> 模型层，大多与数据库打交道
- V -> 视图层，由于我们是前后端分离的，所以前端项目就相当于是View层
- C -> 表示M层与V层之间的纽带和桥梁 -> 作用，可接收前端发送过来的一些请求，然后根据这些请求进行一些业务逻辑上的处理，然后再连接数据库，操作数据库 -> 当数据库返回对应的操作失败或操作成功这样的结果时，就是返回到了C层 -> C层再把结果响应回给前端

所以，这个代码流通就是一种MVC模式哈！

因此，我们要把M层和C层写在后端！

目前，我们使用的是原生的koa，并没有使用基于koa的那些现成框架，如阿里的egg.js，360奇舞团的think.js

而在这些现成的框架里边，都给我们定义好了MVC每一层的文件夹了

由于我们用的是原生的koa，所以我们就得手动的去搞MVC了

5）创建模型

1. shop_server -> model -> User.js -> 名字规范，User首字母大写，而且User这名字与我们数据库里边的集合名字是一样的，说白了，在关系型数据库里边，这叫User表哈！
2. user.js -> mongoose -> mongoose提供了Schema方法 -> 需要new的变量，请用首字母大写哈！
3. 创建User集合模型 -> 这是在搞Field的模板啊！ -> value有多个选项需要配置的话，请用 `{}`，如果就只有一个数据类型的话，那就用

``` js
// model/User.js
const mongoose = require('mongoose');
const Schema = mongoose.Schema;
const userSchema = new Schema({
    userId: Schema.Types.ObjectId,
    userName: { unique: true, type: String },
    password: String,
    createDate: { type: Date, default: Date.now() }
});
```

模型相当于是数据库里边的集合或者习惯叫法「表」，然后选项对象里边的key对应着每条数据里边的每个字段哈

简单来说，**选项对象参数就是一个document，我们要定义一个document有哪些字段，以及字段值的类型是怎样的，字段值是否是唯一的等等**

6）发布模型

必须要发布模型，不然，后边是无法引入的

``` js
// User.js
// 发布模型
mongoose.model('User', userSchema);
```

7）如何引入模型

模型也是mongoose的一部分

安装：

``` bash
yarn add glob
```

同连接MongoDB一样，需要初始化：

``` js
// init.js
// 引入所有的schema
const glob = require('glob');
const path = require('path');
exports.initSchemas = () => {
  // 把model旗下所有的js文件一个一个遍历地引入进来
  glob.sync(path.resolve(__dirname, './model', '*.js')).forEach(require);
};
```

``` js
// index.js
const { connect, initSchemas } = require('./init.js');
(async () => {
  await connect();
  initSchemas();
})();
```

> connect是个函数，它返回一个Promise对象，其中有个异步操作，即连接数据库是个异步操作，所以我们需要等待连接数据库成功后才去初始化一个个模型，因此我们需要用到async/await，然后自执行！
> 
> 总之，要连接数据库之后，再去初始化模型，不然数据库如果连接没成功，那么这初始化模型就没有意义了！
> 
> 异步操作自带不等结果，所以我们用async/await后，可以控制异步任务的执行流程，如可以用await这样的关键字等待异步任务返回的结果，然后再执行接下来的代码！

接下来，看看如何接收前端项目发送过来的请求


## ★注册功能

- 前端页面编写
- Axios发送请求
- koa路由：`npm i koa-router --save` 配置路由
- Post参数：`npm i koa-bodyparser --save`
- 加盐加密：`npm i bcrypt --save`
- 跨域：`npm i koa2-cors --save`

1）路由？

前端路由 -> 单页面 -> url变 -> 组件切换

后端路由 -> 前端请求url -> 根据url找到相应的路由处理函数

安装路由：

``` bash
yarn add koa-router
```

2）路由使用

1. 创建controller目录 -> 表示MVC的C层
2. 在controller旗下新建个user.js -> 表示用户的路由 -> **首字母小写**
3. `user/registerUser` -> 表示有个user控制器，然后user旗下有个registerUser方法 -> 我之前理解成了**二级路由**
4. 前端是用啥方法发送请求的，后端就用啥方法去接收请求，如前端post，那么后端路由也用post
5. 跨域 -> 前端项目和后端项目不是在同一个端口，即一个是8080，一个是3000 -> taobao的前端，能向京东的后台发送请求吗？——显然这是不能的！除非京东后台允许 -> 之所以会有跨域，是因为浏览器的同源策略
6. 后端发送过来的数据，被前端then里边callback所接收

3）跨域处理

解决跨域的方式有很多种

我们选用这一种：

``` bash
yarn add koa2-cors
```

在index.js里边配置：

- 指定哪些源头可以请求我们的后端，如只允许我们的前端项目
- credentials：设置证书

``` js
// index.js
// 解决跨域问题
const cors = require('koa2-cors');
app.use(cors({
    origin: ['http://localhost:8080'],
    credentials: true
}));
```

➹：[9种常见的前端跨域解决方案（详解） - 掘金](https://juejin.im/post/5d1ecb96f265da1b6d404433)



