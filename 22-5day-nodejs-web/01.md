# 原生nodejs的基础使用

## ★TPR？

<mark>1）什么是Node？</mark>

* 一个让JS运行在服务端的开发平台
* 2009，5月份发布
* 其本质是v8引擎（一个由Google开发的开源的高性能JavaScript引擎）的封装

Node它不是一门独立的语言，也不是一个JS 框架，而是一个JS 的运行环境。我们在前端页面写的JS 是由浏览器负责执行的，而我们这次要学的Node，其实是在后台运行的JS 。

目前，还没有一家公司完完全全用Node.js 来做服务端，说白了，Node.js 目前是打辅助的，一般它在工作中的用途是这样的：用来做中间层（从架构上理解中间层和中间件的区别）、小型服务（一些促销活动，如果后台忙不过来的话）、构建一些小工具（如webpack这样的自动化工具）

简单来说，中间层就是这样：

![中间层](assets/img/2020-01-06-16-58-39.png)

> 中间层是一个常见的web架构。构建：构想并建立（多用于抽象事物）

注意，一个观点：「目前，没有哪家公司可以用Node.js 来独当一面的来做后台服务」

<mark>2）为啥Node那么火？换句话说，它有啥优势？</mark>

* 便于前端入手，毕竟写的都是JS代码
* 性能出众
* 利于和前端代码整合（如数据校验，数据入库，旧姿势是前台一套，后台一台（Java/php），而现在有了Node.js之后，就写一套就好了）

<mark>3）DOM 和 BOM是存在于哪儿的？</mark>

它们俩只在于浏览器，在node里边是咩有它们俩的！而这意味着，你写Node.js 代码的时候，就不能用dom对象和bom对象了

<mark>4）IO？</mark>

简单来说，IO就是读写文件，如输入输出、请求响应等等

程序在执行的过程中，必然会进行很多的IO操作，注意IO不是并发，而是读写！

IO操作很费时，如你要正常去读写一个文件，这样整个线程就会暂停下来，等到这个文件读完后，再继续执行，可见，IO换句话说就是阻塞了代码的执行，而这样一来就导致了整个程序的效率降低

阻塞IO会等待，而非阻塞IO则不会等待，即在程序的执行过程中，IO操作不会去阻塞程序的执行，即在IO操作的同时，继续会执行其它的代码！

得益于Node.js 的事件循环机制，让node环境下的IO操作是非阻塞的！

<mark>5）nodejs的好？即为啥那么多公司喜欢用它？</mark>

1、nodejs依赖于v8引擎进行代码解释，所谓的v8引擎是一种JS 引擎的实现，而JS 引擎又是什么呢？它是一种用来执行JS 代码的解释器。v8引擎它是开源的，底层是c++，号称是最快的JS 引擎

2、nodejs是基于事件驱动的，所谓的事件驱动，可以理解为一种模型，其实，像「模型」这样的东西，是很抽象的，如在js里边有个叫onclick事件，这个事件代表鼠标按下，而鼠标驱动模型的大体思路是怎样的呢？——在内部会有个事件或者说是消息队列，当我们按下鼠标，会往这个队列里边增加一个点击事件，同时还会有一个循环，而这个循环的形式是 `while(true){}` ，可见这是死循环，通过这种方式不断地去从事件队列里边取出事件，然后根据不同的事件去调用不同的函数！由于保存着一个事件对应着一个函数地址，这样就保证了每个事件都有一个独立的处理函数！而nodejs它也是采用事件驱动的运行方式，它的内部会有一个主线程来维护一个事件循环！

3、非阻塞I/O

4、基于单线程的

<mark>6）进程和线程？</mark>

* 进程：系统里边正在运行的一个应用程序，如QQ、网易云音乐等这些程序，一旦运行，就是一个进程
* 线程：进程内独立执行的一个单元流，换句话说，就是「程序执行流的最小单元」，如我们的qq在执行的时候，是可以语音和视频的，而这个时候的语音和视频就可以理解为QQ进程里边的一个线程在执行

Node.js 之所以那么牛逼，很大原因是因为它的性能牛逼

举栗来说：

你开了一个大保健，最开始的时候你聘了很多技师，每来一个客户就让一个技师去服务，有一天，同时来了好几百位客人，甚是火爆，于是，你就派了几百位技师一对一的为这几百位客人服务，看起来这一天会赚大钱，但是聘请的技师太多了，所以最后也没挣到啥钱……

总之，以上是一种传统姿势——客户多了，技师就得多，不然，技师都在服务，剩下的客人在排队等候的话，下次就不来了……这样一来二去的，生意自然就惨淡了，逐渐地，就等着关门吧……

为了防止这种情况发生，于是你只聘请了一个技师，而这位技师贼牛逼——漂亮，服务好，技术好，简直是技师界里边的王者

有了这样一位技师，客人们自然心甘情愿地来等

话说，这个栗子跟Node.js 有啥关系呢？

我们知道在传统的Java、PHP里边，它们会为每一个客户端的连接创建一个新的线程，而每一个线程所耗费的内存大概是2M，所以理论上一个8G的内存的服务器，它可以同时连接的最大用户数，大概是4000个

由于业务的拓展，我们的web应用程序会支持更多的用户，那么这就需要去增加服务器的数量了，如果不增加，那么这就意味着你的服务器的服务就会被挂掉

然而，服务器是很贵的，可在java、php这样的语言下，如果要扩展业务，只能加服务器了，毕竟这是由java和php的语言本质所决定的，只要来一个用户，就得创建一个线程

然而，在Node.js 里边，它不会为每个用户连接创建一个新的线程，而是仅仅使用一个线程来做这件事，所以Node.js 它是单线程的

当用户连接了，就会触发内部的一个事件，通过「非阻塞I/O」、「事件驱动机制」，然后就会让程序看起来也像是并行的那样

如果你使用Node.js 来搞，那么一个8G的内存服务器，就可以同时处理4万个用户请求

可见，4000与4万，显然选择后者哈！

可以看到，使用单线程会有这样一个好处哈！（所谓的单，就是一个线程完成所有的任务，并不是多个单线程完成多个任务，然后看上去每个线程都在单独完成一个任务那样）

换言之，Node.js 的承载、负载是非常不错的

当然，单线程它也有一个坏处，那就是当用户的那个线程崩溃以后，那么整个服务都会崩溃

不过，现在这也没啥关系了，因为我们的服务器基本会配置pm2（带有负载均衡功能的node应用进程管理工具）——进程守护工具（服务崩溃后，可以平滑无缝启动服务），除了pm2（用得比较多）以外，还有forever等

总之，Node.js 的性能很牛逼，而这一点最简单的体现就在于它是单线程的！（8G内存，java只能处理4000个，而nodejs能处理40000个）

**➹：**[PM2简易使用手册 - 掘金](https://juejin.im/post/5be406705188256dbb5176f9)

> 一般服务器的部署用的是Nginx

## ★基础知识

1）Node.js 安装

下载LTS版的：[Node.js](https://nodejs.org/en/)

2）管理npm包的下载源

安装nrm就好了：

1. `nrm ls` ：查看有哪些源
2. `nrm use taobao` ：使用哪个源，如这里使用的是淘宝源

> nrm是一个管理源的工具

不过一般会推荐你使用yarn去安装npm包，因为它很快哈！

> 镜像：如果你了解过docker，你就会知道镜像有点像是拷贝，总之，可这样理解 镜像 -> 拷贝

3）测试「非阻塞I/O」

``` json
{"name":'我是你大桃哥啊！'}
```

``` js
const fs = require("fs");

fs.readFile("./data/name.json", (err, data) => {
  if (!err) {
    setTimeout(() => {
      console.log("我要等3s才执行");
    }, 3000);
    console.log(data.toString());
  }
});

console.log("我要最后才执行");
```

log 结果：

``` 
我要最后才执行
{"name":'我是你大桃哥啊！'}
我要等3s才执行
```

fs.readFile是个IO操作，由于Node.js 是非阻塞IO的，所以不会等它读完文件后再去执行最后那行log！

不管怎样，IO就是读写，如读写文件、操作数据库等都是基本的IO操作

4）建立http服务

## ★总结

## ★Q&A

### 1、程序执行流是啥？

> 很简单，你读书是怎么读的？一行一行读的对不对？那么这个就叫读书流。源码也一样，被执行的时候是一行一行走的，当前执行到哪里，就叫流到哪里。整个过程又被称为执行流。

**➹：**[“程序执行流”是什么意思?_百度知道](https://zhidao.baidu.com/question/401410292.html)

**➹：**[进程与线程的一个简单解释 - Corwien - SegmentFault 思否](https://segmentfault.com/a/1190000005884656)

