---
typora-copy-images-to: img\09
---

# 简单轮子：Tab 组件

## ★课程简介

代码链接： <https://github.com/FrankFang/frank-test-1/tree/tabs>

UI：<https://www.yuque.com/u29422/gulu/268970>

![image.png](img/09/2018-7-30-15-44-1.png)

## ★最近反馈的问题解答

1. github发现 了潜在的隐患，这是因为我们的代码用了很多其它的库的缘故（可以查看package.json的依赖和开发依赖字段以及package-lock.json）。

   ![1563865148286](img/09/1563865148286.png)

   隐患缘由：

   ![1563864759878](img/09/1563864759878.png)

   因此所有人都需要重新登录，然后换个token后，这些包才是有保障的！不然，该包风险就很大了。

   > `.npmrc`文件下会有个缓存的token

   解决方案：

   要么点击去看隐患代码，看看能不能解决（需要更lodash版本为最新之类的，但是我找不到是那个库依赖了它，万一更新了，导致整个项目都蹦了？）；要么就是dismiss，即风险自担。

   ![1563865502643](img/09/1563865502643.png)

2. 用了cnpm的话，那就把它卸载掉吧！因为该工具的维护目前并不活跃呀！总之，你就设置淘宝源即可！而cnpm没有使用价值了

3. 如果项目是用npm这个包管理器来init，那么就不要随便改成是yarn这个包管理，不然这是很容易出问题的！

4. `parcel watch test/* --no-cache & karma start`，window不支持 `&`，即无法让终端同时运行二者，你可以打开两个终端，分别使用 `npx`来执行它们。改成两个 `&&`也是不行的，因为 `&`和 `&&`意思是不一样的。

5. 如果你想学命令行，那就装个深度系统或者是Ubuntu系统…毕竟windows的功能太差了

6. vue有没有好的文章推荐？——芳芳觉得搞清楚官网文档就非常好了，当然，你就关注那个点，然后 就如「vue 响应式数据」这样去搜索文章呗！

7. 如果遇到使用工具的报错信息，那么就复制报错信息到google上搜索

## ★解决bug的思路

> 如何解决突然出现的bug？（如 `npm run test`发现一个测试用例不通过）——不用问人，因为这有亘古不变的debug办法

![1563867322717](img/09/1563867322717.png)

分析：

1. 在1万多行的位置？——显然这是parcel打包后的结果，因此我们并不知道报错点在哪儿，但是我们知道这跟 `toast.test.js`这个文件有关

   我的是在这行：

   ![1563867608079](img/09/1563867608079.png)

2. 可以看到可能是我们的 `this.$refs.line`为undefined，因此我们需要通过log大法看看它是什么，当然，你也可以用debug，但这忒TM麻烦了。

   > 通过报错信息提示，定位到有bug的代码

3. 分析产生bug的原因：二分法确定是哪个测试用例报错了，然而，令人无语的是，单独打开每个测试用例都不报错，但是全部打开就报错了。——存在缓存的问题，其实是第二个测试用例的问题呀！

   ![1563868864017](img/09/1563868864017.png)

   > 在 `$nextTick`执行前，是你在mounted里边log `this.$refs` 是有的，但执行nextTick之后，就为undefined了，所以可见这中间是存在某种过程导致了（异步执行的时间差），`this.$refs`消失了

4. 分析

   ![1563869723718](img/09/1563869723718.png)

5. 解决bug——搞个定时器执行后边两行代码即可：

   ```js
   let closeButton = vm.$el.querySelector('.close')
   expect(closeButton.textContent.trim()).to.eq('关闭吧')
   setTimeout(()=>{
     closeButton.click()
     expect(callback).to.have.been.called
     done()
   })
   ```

   测试，发现这个bug消失了。可见这是我们测试用例写得不周全呀！而且也可以看到，nextTick的回调先于setTimeout的回调先执行呀！

> 总之，你得分析清楚，这个测试用例的代码执行是如何走的，比如哪个函数先执行后执行。总之注意时间差的问题，即异步那些事儿。

小结：

![1563869270961](img/09/1563869270961.png)

---

## ★需求分析

### ◇我想造个轮子？

做每一个轮子之前都要经历这4步，如果少了任何一步都会出现很大的问题：

1. 需求
2. UI
3. 代码
4. 测试

大部分程序员只管代码，导致ta做的需求有问题、UI有问题，或者说测试不通过

总之，你自己一定要把这4个都得过一遍

有的时候需求不是你写的，但你也要看一遍

UI不是你做的，你也要核对一下

测试虽然有帮你测，但你自已也要测一下

而这样才算一个完整的开发流程

### ◇Tabs的需求

1. 需求：

   ![LffD7ny2ok](img/09/LffD7ny2ok.gif)

   你切换得分，就展示得分相关的内容；你切换篮板就展示篮板相关的内容……

2. 分析这个需求（画个用例图就好了）：

   一分析得知，就是个tab的切换，似乎就没有了。

   当你想不到任何分析的时候，那就去参考业界的，有很多人认为抄袭是很可耻的，但是在软件工程里边有个原则就是，尽量让你的东西跟业界里的差不多，比如360的杀毒软件，和QQ的安全管家，你看它们俩是不是差不多的？而这样做的原因是为了减少用户的学习成本呀！

   所以抄袭人家是怎么做的轮子并不可耻呀！

   分析ant-design的tabs：

   - 可以禁用tab，不过这个tab挺鸡肋的，如果在做后天管理系统时，需要权限的话，才能访问这个tab的话，那倒不如不显示这个tab嘞！
   - 字体放大就不做了，让用户自己用CSS调吧！
   - 有好几个需求，我们就挑了4个需求来做，其余的需求，有时间可以自行去做

   ![1563879136295](img/09/1563879136295.png)

   

3. 分析要做需求的UI，直接抄ant-design的UI就好了

4. 其它人如何用你的tabs？

   1. element-ui的姿势：

      ![1563879487977](img/09/1563879487977.png)

   2. 芳芳提供的姿势（代码复杂点，但结构清晰）：

      ![1563880806192](img/09/1563880806192.png)

      为了让我们的代码好写，所以需要加上个name属性，而这是权衡出来的结果，反正你如果因为需要取个名字而犯难的话，那么我劝你还是不要用这个库了：

      ![1563881081799](img/09/1563881081799.png)

   为啥选择第二种？——因为保证了层次结构：

   ![1563881276811](img/09/1563881276811.png)

   而element-ui则是父子关系层次结构：

   ![1563881337970](img/09/1563881337970.png)

   总之各有各的好处咯！随你喜欢

   以上是芳芳所规定的API，而我们也可以规定自己所想要的API

5. 想好怎么用之后，就可以开始想想怎么用代码做了，当然，这tab的组件会稍微有点复杂哈！

---

## ★创建五个组件

> 想好别人怎么用我们的组件，就可以开始写组件了。

1. 根据设计的API，需要搞5个组件，即一个标签一个组件
2. 从最外边那个组件（tabs）开始写（当你不知道要写啥的时候，就直接写那3个标签即可）
   1. 写个root元素，即div
   2. 根据设计的div，我们需要把内容插进去，因此用到 `<slot></slot>`，如果不写这个，那么Vue就会删掉用户写上的子元素
3. 写tabs-header（也可以叫tabs-nav，算一个好记的就可以了）。
   1. 我们为root元素写上了class `tabs-header`，这里的中划线表示父子关系
4. 写tabs-item（都以tabs为前缀好了，写代码最烦的就是起名字了，如果名字起得好，代码就好看了，而名字起得烂，就很容写错代码了，总之你要花点时间起名字）。
5. 写tabs-body
6. 写tabs-pane

芳芳起得名字都很规整，多想想自己能否做到这样

接下来用index.hml来做测试，这个文件最后最终都会被删掉哈！

还有app.js这个文件最后也会被删掉，目前来看虽然import了很多东西，但并不需要去优化它哈！毕竟我们人的精力是有限的，该优化的地方就去优化，不该优化的（最终都是被删掉的），那就无脑的去抄就好了，如 `import`组件，注册组件，而不是什么都要去优化。

> 关于vim的学习，芳芳都学了好几年。而如果学会了，那么这代码就写得贼快了。

注意：**由于HTML的风格是head对应body，header对应footer，所以那个tabs-header组件，最好改为tabs-head。**

至此，tabs-head、tabs-body、tabs-item、tabs-pane，都是4个字母结尾的，这让处女座的人看起来是非常舒服的！

当然，你不改也没有任何关系，随你喜欢。

此时的API：（你会发现element-ui那种设计是有它的道理的，即更简洁，而芳芳的则是为了结构更为清晰，所以各有千秋呀！）

![1563934626918](img/09/1563934626918.png)



- 规定输入参数以及需求：

  - tabs组件只有一个参数，好不好呢？——显然这不好呀！因为我们需要tab切换呀！一旦tab切换，那么selected的值也要变啊！于是我们加了个事件监听，可是为啥要加事件监听呢？

    那是因为：子组件是不能改父组件的任何值的，如果用户要改变一个tab，那么不能在子组件里边改，而是一定要通知爸爸 `#app`去改，为啥要这样呢？——因为selectedTab是 `#app`的数据呀！所以这不能由别人改。

    因此，就必须要有一个事件了。

    **➹：** [②](#er)

  - 方向（决定tabs是竖着还是横着）：tabs

  - disabled（禁用）：tabs-item

  - 添加icon：只需要加个icon标签即可

  - 额外的按钮：tabs-head，需要多加一个插槽，[③](#san)

其它诸如删除或添加tabs就不做了。

目前的API结构：

![1563935633069](img/09/1563935633069.png)

`commit:添加 tabs 相关组件，添加基本 props`

---

## ★依赖注入和eventBus

### ◇上一节的反馈？

- 没有想到需要用到 `.sync`，关于这个你习惯就好了，因为所有造轮子的人都需要知道 `.sync`什么时候去提供，总之，目的就有一个，那就是给用户吃一颗糖，让它甜一甜。当然，不用 `.sync`也是可以做到的，那么这就需要写一个绑定，然后再写一个事件监听了，而这就很麻烦了

- 添加 `g-tabs-head`的目的，就是为了让用户可以在其身上添加class：

  ```html
  <g-tabs-head class="frank"></g-tabs-head>
  ```

  ![1563949013382](img/09/1563949013382.png)

  文档里边说了：如果你给了一个自定义标签一个class，而本身的template又有class，那么vue默认是合并的，而且只有两个属性是这样的——Style和class，其它属性则是直接覆盖。至此，我们就很容易就可以给tabs-head添加一个背景色了，可见这要比element-ui要好，毕竟这是一种无侵入的、比较好改样式的API。

### ◇想想怎么做Tab切换？

#### 画个图搞清楚逻辑

- 组件的结构（目前是126结构）：

  ![1563950129986](img/09/1563950129986.png)

- 爷爸孙通信：爷看到了 `selected=item1`，那么就把 `item1` 交给 `t-head`和 `t-body` 这个儿子， 同理， `t-head`都把 `item1` 传给了它的 3个儿子 `t-item`，这些 `t-item`们会识别 这个信息是不是给自己的，如果是自己的那就亮一下呗！不是，那就不亮呗！

  总之关键点，在于都传。

  总之，这是我们在有赋值的时候，如何去表示被选中的逻辑。而这个传递过程，我们的代码也有类似这样的传递过程

- 如果用户点击了第二个item2，那么应该发生啥事情呢？

  - 兄弟组件之间是没有办法通信的，即item1和item2是没啥关系的，即item2要点亮，请item1熄灭吧！这是做不到的。

  总之，这需要做5件事：

  - 自己亮起来
  - 哥哥你熄灭吧
  - pane2亮起来吧
  - pane1你也要熄灭哦
  - 爷爷，你的 `update:selected`事件要被触发哦！触发后就得让selected值变为 `item2`哦

![æè·¯](img/09/2018-7-30-18-56-56.png)

> 这就是理解数据结构的好处了——这图就是一个颗树啦！

#### 逻辑清楚了，那就想代码细节呗

![EventHub/EventBus](img/09/2018-7-30-18-57-18.png)

1. item2如何通知pane2？——我通知爸爸，爸爸通知我爷，爷通知我二叔，二叔通知我爷的二孙子**亮灯**。与此同时，通知我爸时，爸通知大哥**熄掉灯**

   可见这样的通知路径是有点复杂的，即又上又下，蹦蹦跳跳的，难道就不能直接打个电话通知一下吗？非得搞得像层层汇报一样

   所以能不能简单点啊？——添加个第三者就好了，而这第三者也叫做  `EventHub`（事件中心），有些地方也把它叫做`EventBus`（事件总线）

2. 怎么个中心法？——item出现一些变化，就直接通知给事件中心。而事件中心则通知所有节点，注意这是所有节点啊，而不是相关的节点。

   虽然需要通知很多节点，但是这变简单了许多，而这本质上就是一个发布订阅模式，即谁变了，就发布一个事件，而其它节点就只管订阅就好了。

   > 是不是说只有订阅用户，事件中心才会把item2触发的事件通知给订阅用户？我之前认为是，事件中心通知给所有节点哦！

   这种方式看起来，咩有比之前那种粗暴姿势（通知爸爸爷爷，然后爷爷通知二叔……）简单点，但是写起代码来就要简单很多了。毕竟item2只需要发布一个事件，然后其它所有组件节点只需要订阅这个事件就好了

可见，我们有两种姿势完成通信：

1. 「爷爷爸爸儿子之间的亲密谈话」
2. 「事件中心」

你说哪种好呢？——通过芳芳讲解知道，是第二种比较简单啦！

但是，如果你信邪的话，你也可以试着走走第一种怎么做，芳芳期待了不信邪，因为这样你就可以走一些弯路了，而你走的所有弯路都会变成你的经验。



### ◇搞个事件中心出来

> 需要提供（provide）一个事件中心（Vue的文档里边写了有怎么提供）

那么这该如何提供呢？——让tabs组件来提供（话说，让tabs组件来提供好吗？——因为不知道tabs组件能否拿到写在自己身上的事件中心）：

**第一次尝试：**

1. 需要在tabs组件里边引入Vue

   ![1563959908236](img/09/1563959908236.png)

2. 结果发现没有这个provide的属性，即我们无法访问写在自己身上的事件中心。简单来说，就是自己提供的东西，自己访问不到

**第二次尝试：**

1. 所以我们还得再加一层中转——用data做中转

   ![1563960327102](img/09/1563960327102.png)

   > 突然发觉为啥，要用tabs作为事件中心了，因为tabs组件是爷爷呀！即它只有一位爷！
   >
   > 总之，eventBus就是一个Vue的实例，仅此而已，而它之所以能让爸爸组件、孙子组件访问到，那是因为我们provide了。
   >
   > provide是个特殊的API，或者说是特殊的对象选项。

2. log一下this有哪些值：

   ![1563960635136](img/09/1563960635136.png)

   provide出去的eventBus是来自于data里边的eventBus属性的引用。

3. 只要我们在爷爷这个组件上写上`provide:{eventBus}`的话，那么它所有的子孙后代就都能访问到这`eventBus`，说明`provide`这个属性是唯一一个可以跨组件都可以调用的属性，而其它的属性都是只提供给儿子，不提供孙子（如props属性），总之，**只有provide是任何后代都可以访问的**

   **➹：**[vue 父子组件间通信 - 个人文章 - SegmentFault 思否](https://segmentfault.com/a/1190000014381699)

### ◇让后代访问eventBus

儿子tabs-head表示想要访问：

1. 写个inject属性，即注入（不注入是没有eventBus的，反正你注入了，所有后代都会有的）：

   ![1563961793642](img/09/1563961793642.png)

孙子tabs-item表示也想试试：

![1563961926493](img/09/1563961926493.png)

同理，其它的爸爸儿子都这样搞，因为它们都需要知道那个item被选中了。

测试（xx item 被点击了，所以xx item需要通知所有人）：

> name属性，可以是Number类型的，因为方便给个1234这样的名字

![1563962661844](img/09/1563962661844.png)

> 必须要给name属性

所有后代组件都得监听这个 `update:selected`事件

> 为啥所有后代组件都得监听呢？——这不是同一个Vue实例对象吗？
>
> 难不成这类似于订阅 `update:selected` 事件？
>
> 如果某个组件咩有监听的话，那么是无法收到xxx item被点击的信息？

总之，自己触发，自己监听，都得写上，毕竟，有时候不是你自己触发的，而是其它item触发的，那么`xxx()`就不会执行，而 触发的事件的callback就会执行；也有写时候，自己触发，同时也执行自己写上的callback。

> 再次自以为是的理解每个后代组件都得监听这个 `update:selected`事件的原因：
>
> - 儿孙后代们啊！请订阅这个事件
> - 儿孙后代们啊！订阅了这个事件，你们都能写上自己想要的callback了
>
> 或许你会怀疑，为啥绑定在同一个eventBus，即Vue实例的 `update:selected`事件，会执行不同的callback？
>
> 或许这是因为，`inject`这个API所起到的作用，它可能为每个callback都搞了标识之类的。

效果：

![1563963570865](img/09/1563963570865.png)

同理，其它组件也要订阅监听：

> log测试完毕，就得删掉，千万不要留在代码里边。

至此，我们就完成了谁该亮的操作了。

`commit:注入eventBus,在每个组件上监听update:selected事件`

> 注入的是事件中心必须是Vue对象吗？——不是的，你用原生JavaScript搞得也行，只是，我们使用Vue更方便罢了。
>
> 我们还可以用Vuex这个插件来搞这样的事情。

### ◇一个问题

![1563964984914](img/09/1563964984914.png)

这是不会执行的。

很多用Vue的人会有这样一个误区——总觉得这是事件更其它原生的DOM事件一样，你在哪儿触发，就会冒泡到上边去给其它监听了该事件的元素执行callback。

至此，你一定要记住的一个重要的原则是：

- Vue的事件是不会冒泡的，你在哪儿触发的事件，就会在哪儿触发它的callback

话又说回来，eventBus是哪儿来的？——在tabs.vue里边的data的eventBus的属性的 `new Vue()`

而监听 `update:selected`这个事件的是g-tabs元素呀！

而g-tabs是啥呢？——它是一个Vue组件，即我们监听这个事件的是Vue组件，而不是 `new Vue()`在监听，而它们俩是没有关系的。

那么g-tabs组件如何触发这个事件呢？——

![1563965785586](img/09/1563965785586.png)



那如果我用eventHub呢？——那么就是另外一个事件系统了。

![1563967208671](img/09/1563967208671.png)

结果：

![1563967228035](img/09/1563967228035.png)

第二行啥事都没有发生。

结论：

1. 你得知道你触发的事件是在哪个对象上触发的，不是说名字一样那就都可以，毕竟一个可以在this上边，一个也可以在this的`eventBus`上边
2. 其实我们只是想调用 `update:selected`事件的callback罢了。
3. 其实每个对象都可以触发不同的事件，总之事件是要看在哪个对象身上触发的。

再问：「我在tabs-head里边能触发yyy吗？」

> 学造轮子会让你更好地学习Vue，因为你能研究更细的东西

![1563967623003](img/09/1563967623003.png)

> 我认为这不会，因为这TM不会冒泡啊！

结果，不会。因为Vue的事件系统是不会冒泡的。

![1563967730345](img/09/1563967730345.png)

如果儿子是div，那么点击该div，那么点击事件时会传到它的爸爸身上的，因为这叫做事件冒泡啊！

但是如果g-tabs-head里边触发一个同名的事件，那么这是不会自动冒泡到它的爸爸身上的。

那么能不能冒泡到爸爸身上呢？——一般来说，请不要这样做。如果你非要这样干，也是有办法的：

component-child:

```
this.$root.$emit('foobar',{...});
```

component-parent:

```
this.$root.$on('foobar')
```

**➹：**[javascript - How to bubble events on a component subcomponent chain with Vue js 2? - Stack Overflow](https://stackoverflow.com/questions/42029150/how-to-bubble-events-on-a-component-subcomponent-chain-with-vue-js-2)

但是芳芳认为这不太好，因为有需求的时候再说比较好，而现在说，并不知道这到底好不好，而现在没有需求，那就先不这样用咯！

> 我认为这是真得不好呀！因为假如事件冒泡的了，那么事件的callback该什么时候执行呢？
>
> 假如template是这样的：
>
> ```html 
> <div id="app">
> 	<g-tabs @xxx="yyy">
> 		<g-tabs-head>
> 			<g-tabs-item><g-tabs-item>
> 		<g-tabs-head>
> 	<g-tabs>
> </div>
> ```
>
> g-tabs-head在created这个钩子里触发了xxx事件，然后冒泡到g-tabs身上，执行yyy这个callback
>
> 可是g-tabs-item的编译，会不会被阻止呢？——照理说应该会阻止。
>
> 测试得知，不会阻止：
>
> **➹：** [demo](./demo/09/vue事件冒泡.html)

###  ◇小结

1. 详细讲解了Vue事件。其中需要注意两个点：
   1. 事件是在哪个对象上被调用的，即被触发的。总之，你在哪个对象上调用，那么你就只能在哪个对象上监听了。如你在eventBus上监听的事件，那么你只能在eventBus这个对象上触发事件了。除此之外，就没有其它地方可以监听了。
   2. 事件不会冒泡，你在子标签上触发的事件不会自动传到父标签上边，那孙子就更不用说了。

---

## ★如何切换Tab？







## ★总结

- 以后看template，请以树的角度去看，定位到root组件节点（一般都是 `#app`，如果站在tab组件来看，那么tab组件就是root组件了），然后一个个后代子组件实例即是一个个节点。

## ★Q&A

### ①framework7的tab？

![1563878977986](img/09/1563878977986.png)

不过framework7做的是真得好啊，可以动画（高级的时候芳芳会讲动画），可以手指滑动，还可以路由等等……

### <a id="er">②tab切换需要触发自定义事件？</a>

当xxx用户，点击 `item` 美女，那么就需要更新 `g-tabs`上的 `selected`值。

为啥需要事件？——因为子组件不能改父组件的数据，这只能由爸爸 `#app` 去改g-tabs上的数据 

事件的名字：

![1563936196480](img/09/1563936196480.png)

当用户点击美女item，那么就会触发 `update:selected`事件

总之`update`后边接收的是属性的名字。

> 加冒号是表示 `selectedTab`是个变量，而不是字符串

selected值，目前是不需要的，如果不爽，那就给个默认值。

在某个时期，就会触发 `update:selected` 事件，而事件的值目前还不知道。

为了是 `.sync`修饰符有用，我们必须要触发这个事件：

![1563936607326](img/09/1563936607326.png)

> 要理解这个过程，你需要带着把模板编译后的眼光来看：
>
> 我们点击了tabs-item这个div，显然原生里边这是个click事件吧，然后执行它的callback，而callback里边有我们要触发的自定义事件—— `update:selected`，而这个事件显然也会触发一个callback，而这个callback是干嘛的呢？——比如tabs这个div的selected属性改为「woman」
>
> 以上的理解也是需要前置知识，如了解JavaScript的事件、异步回调等知识。Vue 框架，把我们构建自定义事件这件事变得简单了很多。至于其是如何做到这么简洁的，那就不是我所关心的事儿了。反正这API是Vue作者自行设定，而你只能接受这样的API，接受这样的使用。
>
> 所以请不要理解如何用（直接抄就好了），而是要理解这背后的执行过程（记得更深刻）。
>
> 总之，修改tabs的selected属性值，是tabs组件自己完成的，而tabs-item只是发个通知，并附带个参数给你。

**➹：**[自定义事件 — Vue.js](https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6)

### <a id="san">③如何在一个组件里边添加多个插槽？</a>

![1563937181551](img/09/1563937181551.png)

如何让tab-head组件有两个插槽呢？

![1563937228123](img/09/1563937228123.png)

测试多加的action插槽：

![1563937341463](img/09/1563937341463.png)

编译后的结果：

![1563937414775](img/09/1563937414775.png)

### ④vue实例中出现有下划线开头的属性？

这些下划线开头的属性不要随便滥用，因为这是私有属性呀！而这些属性是Vue的作者自己用的，不是给我们这些框架使用者用的，我们能用的就是 `$`开头的，这些 `$`开头的，就是Vue作者专门给我们用的。

### ⑤芳芳经常性的xxx命名？

如果我们没有想好一个函数应该起什么名字，那么芳芳的习惯就是把它叫做xxx

表示，这是一个看起来就是需要改的名字，而不是随便给点英文单词之类的。

毕竟一看xxx，就是需要改的；而你一看bus，似乎这名字还有点意思哦！

### ⑥如何搞一个事件中心？（涉及到provide、inject）



**➹：**[API — Vue.js](https://cn.vuejs.org/v2/api/#provide-inject)

