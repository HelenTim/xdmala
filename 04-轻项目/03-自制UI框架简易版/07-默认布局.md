---
typora-copy-images-to: img\07
---

# 简单轮子：默认布局

## ★完善测试用例

### ◇注意点

- 在测试响应式，请这样来：

  ![1563032176326](img/07/1563032176326.png)

  > 表面上看2row，实际上是一个row，因为一个col占了1/3。而这里是一个row里边有6个col。
  >
  > 把屏幕尺寸大小当作是「JavaScript操控class的存在与否」一样。

- 一定要注意：元素身上的class名不要写错了，或者css里边的class名不要写错了，总之你写了个class，那么就得有与之相对应的css，不然，效果就不出来了，而这样显然是有bug的。像我就把 col元素的class为`col-narrow-pc-8`这样的搞成是 `col-narrowPc-8`这样的，起初没有留意到，还以为样式之所以不出现是浏览器缓存的问题呢！

- 我们的响应式弄得很简单，基本上就是布局方面的响应式，如在pc上，一行是3个div，而在手机上则是一行一个div。

- 一次很无厘头的错误：

  ![1563093570133](img/07/1563093570133.png)

  可以理解为模式匹配，左边是变量，而且可以给个默认值。

  况且一个对象得key会是直接一个字符串key吗？

  **➹：**[变量的解构赋值 - ECMAScript 6入门](http://es6.ruanyifeng.com/#docs/destructuring)

- 在写row.test.js的时候，如果你要让异步代码有效的话：

  ![1563098117871](img/07/1563098117871.png)

  > 不写done，意味着异步代码里边的回调不会执行，毕竟该页面已经关闭了。
  >
  > 测试gutter属性，对父组件和子组件的影响，算是比较麻烦了。总之，子组件也会受到父元素身上的属性影响的话，那么得用异步代码了，不然是子组件的style是咩有更新的，就像这样：
  >
  > ```html
  > <div data-v-db6887="" class="row" style="margin-left: -10px; margin-right: -10px;">
  >   
  >   <div data-v-ba2854="" class="col col-12" data-v-db6887="" style="padding-left: 0px; padding-right: 0px;"></div>
  >   
  >   <div data-v-ba2854="" class="col col-12" data-v-db6887="" style="padding-left: 0px; padding-right: 0px;"></div>
  >   
  > </div>
  > ```

  `vm.$el`为何物？

  ![1563098628417](img/07/1563098628417.png)

  

- 重新理解单元测试对代码的理解：

  ![1563098453366](img/07/1563098453366.png)

  > 不需要异步代码是因为，该align属性只作用于父组件，毕竟它就是flex容器哈！该row实例mounted到页面上就是这样编译过后的模板：
  >
  > ```html
  > <div data-v-db6887="" class="row align-right"></div>
  > ```
  >
  > 我稍微看了一下 `vm.$mount`这个API：
  >
  > - 它是把div这个元素给替换了，而替换的内容是Row.vue里边的模板呀！我之前以为这个模板是作为div这样元素的子元素而存在的。
  >
  > - 如果不写参数，那么模板将被渲染为文档之外的的元素，而且之后你打算挂载到文档里边的话，得使用原生 DOM API 把它插入文档中才可行：
  >
  >   ```js
  >   // 或者，在文档之外渲染并且随后挂载
  >   var component = new MyComponent().$mount() //返回实例自身
  >   document.getElementById('app').appendChild(component.$el)
  >   ```
  >
  >   这次是插入，而不是替换。
  >
  > **➹：** [API — Vue.js](https://cn.vuejs.org/v2/api/index.html#vm-mount)
  >
  > - `Node.remove()` 方法，把对象从它所属的DOM树中删除。
  >
  > **➹：** [demo](./demo/07/01-测试vm-mount这个api.html)

  再次 `vm.$el`

  ![1563099251009](img/07/1563099251009.png)


### ◇How？（移动端优先）

#### 解决「用户咩有写`:ipad`等自定义属性，然后样式选择」的问题

1. 写phone样式（默认就是这个样式），不写媒体查询之类的

2. 搞适配，只写 `min-width`，如ipad是 `≥576px`，那么其媒体查询就是 `@media (min-width: 576px) {}`

   同理，其它适配也是如此

3. 适配的样式是从小屏幕到大屏幕这样写下去的。

4. 测试

而这种做法，也有一种称呼——Mobile First（移动端优先），即你写一个样式，如果没有说是应用到哪个地方（元素）的话，那就往移动端走呗！那么为啥要这样做呢？因为全球市场70%、80%用得都是手机流量啊！很少会有人用电脑去浏览购物网站等……总之，一定要移动优先呀！

![1563180805578](img/07/1563180805578.png)

#### 重构代码

什么时候重构呢？

1. 代码很重复，就可以选择去优化，当然，你也可以不去，总之这得看你有咩有时间
2. 代码看不懂，那就一定要去优化了，这可不管你有没有时间

分析要优化代码的逻辑：

1. 用户使用自定义标签的姿势：

   ![1563181970059](img/07/1563181970059.png)

   用户写一个phone属性，就至少多一个相应的class……

2. 要重构的代码：

   ![1563182714775](img/07/1563182714775.png)

3. 重构后的代码：

   ![1563183725520](img/07/1563183725520.png)

   > - `str = ’‘` ：默认给个空字符串值，这是为默认为phone样式所准备的
   >
   > - 如果用户没有写诸如 `:ipad`、`:narrowPc`等这样的自定义属性的话，那么就是说用户不想做ipad、narrowPc等设备的适配，既然如此那就直接返回一个空数组，即不需要添加相关的class了。
   >
   >   那如果用户写了的话，还得判断有没有写offset、span等属性，如果都没有写那就返回一个空数组呗。如果都写了，或者只写其中一个，那么就push到数组里边，然后返回呗！
   >
   > - 需要注意的是，数组的元素得是字符串哈！毕竟vue的语法规定，是字符串元素的话，就直接追加class名到元素的class属性里边了。

**总之，我们写自定义属性，就是为了产生相应的class。**

接下来，手动测试，看看重构后代码有没有bug。比如你在 `g-col`身上写了 `:ipad={span:12,offset: 2}`这样的自定义属性，那么就看看编译过好的元素身上有没有 `col-ipad-12`、`offset-ipad-2`这样的class。

其实这种测试理应就使用单元测试来做 的，毕竟要测试这5个逻辑一样的自定义属性，用手动测试的话，显然太繁琐和费时间了。

对了，我们来个做是适配的媒体查询的CSS，也是可以重构一波的，如可以再套一个循环，但就目前而言，再套一个的话，会显得很复杂。

### ◇小结

1. 我们实现了row和col的哪些功能？（基本实现成这样就ok了）
   - 横向24列布局
   - col之间可以加空隙
   - col是响应式的，如一行有6个col，在pc上看起来就是1行有6列，而在手机上看起来，则是有6行。

### ◇How？（row、col单元测试）

#### 思路

1. 看看row、col组件需要接受几个参数，如row只有两个参数：`gutter`和 `align`，而col则有：`span`、`offset`、`ipad`、`narrowPc`、`pc`、`widePc`

2. 看看它们有咩有事件之类的，没有就不需要测了

3. 抄袭之前的测试用例，然后删掉多余的测试代码：

   ![1563186371717](img/07/1563186371717.png)

4. 如果遇到需要测试CSS的代码，那么同样是回顾之前测试CSS的姿势，如 `gutter`属性就需要测试CSS了。

#### 测试row

测试row的gutter属性（**单元测试其实非常不适合测CSS**）：

1. 需要测试它的CSS。注意，你不能mount到页面的body上边，因为你会替换掉它，所以你可以用JavaScript创建一个div，然后append到body上，在mount到该div上，这样我们的row编译好的模板就会显示到页面上。

2. 由于row需要用到col，所以我们需要引入col组件，这时，如果你这样做了：

   ![1563187079000](img/07/1563187079000.png)

   那么如何先mount子组件到父组件呢？如果在HTML里边是很好写的，如：

   ```vue
   <g-row><g-col></g-col></g-row>
   ```

   可我们是在JavaScript里边写啊！所以how？——谷歌一下「vue add children」，然而找到的都是HTML姿势，而从这也可以看出vue的官方文档并咩有想象中覆盖那么广那么全。

   自己动手猜测着写：

   ![1563187593177](img/07/1563187593177.png)

   还有一种瞎着写的姿势（这个自己没有去测试，大概也GG了）：

   ![1563188733697](img/07/1563188733697.png)

   我自己想到的傻屌姿势（成功了）：

   思路是：父组件的template的root元素有个id属性，先把该template挂载（`$mount(div)`）到页面上，然后就是通过id属性获取这个dom元素，接着就是把子组件实例挂载到内存里边，然后子组件实例就可以被`appendChild`到该DOM对象里边了。

   **➹：** [demo](./demo/07/02-动态往父组件里边添加子组件.html)

3. 如何动态的往row里边创建一个col？

















## ★总结

- 难怪一般为pc设计的设计稿都在992~1200之间。
- 始终注意不要把老师的理解给抄了
- 更改看视频方式：第一遍（1.5倍或1.8倍）看就大致理解了，然后直接开始抄代码（进一步理解，并记录一些理解注意点）。第二遍（2倍）就写上如何做到的，然后记上一些处理细节、为什么这样做等，总之是加深理解、验证自己的理解。



## ★Q&A

### ①JavaScript 里 创建 出来的DOm对象 怎么销毁它？

引子：

![1563106105246](img/07/1563106105246.png)

咩有API可以做到，自己被JavaScript的垃圾回收机制给回收掉。

而页面上的dom元素，倒是可以用 `xxx.remove()`这个API，DOM树里边的xxx元素给移除掉。

所以要让 `div.remove()`有意义的话，你得拿到Col组件的template的根元素，然后才能 `remove`掉。

**➹：**[JavaScript 里 new 出来的对象 怎么销毁它？ - 知乎](https://www.zhihu.com/question/21628109)

### ②只弄了两套设计稿，一套pc，一套手机，你说在ipad下看这个网页是应用哪套样式啊？

1. 你可以不管
2. 也可以让响应规则往下走

分析第二种做法：

![1563157456770](img/07/1563157456770.png)

> 粉红色线表示「样式应用的屏幕尺寸范围，其中phone所对应的这种样式应用最广泛」，思路主要是利用了CSS的层叠性。

1. 找到[断点](https://ant.design/components/grid-cn/#Col)——屏幕尺寸断点（一般太宽的如xxl是没有设计稿的，所以我们不需要做适配）

2. 假如一个断点范围内就写一个与之相应的样式（有最大值和最小值），如有5个断点范围，那就写5个。可是这样会有bug，毕竟这个规则写得很死呀！比如说，咩有写ipad样式，那么ipad就真得没有被适配的样式了。

   ![1563158201511](img/07/1563158201511.png)

3. 只给一个最小值。例如，假如屏幕尺寸是580px的话，那就会应用ipad的样式了，而默认的phone的样式会被层叠掉。同理，如果是780px的话，那么就属于n-pc的范围了，于是就会应用n-pc的样式。当然这前提是，col标签有5个需要适配的类，可是如果用户咩有写ipad类呢？即没有ipad样式，那么580px就会往下走选择phone的样式了。（退而求其次姿势）

理解这个图之后，你就能从形象上理解这个适配代码了：

```scss
.col {
    $class-prefix: col-;
    @for $n from 1 through 24 {
      &.#{$class-prefix}#{$n} {
        width: ($n / 24) * 100%;
      }
    }

    $class-prefix: offset-;
    @for $n from 1 through 24 {
      &.#{$class-prefix}#{$n} {
        margin-left: ($n / 24) * 100%;
      }
    }
 
    // 适配5种屏幕尺寸的设备：
    // 默认是all类型的，我认为不同屏幕尺寸下可以不用24个格子，可以选择16、12这样的

    // sm
    @media (min-width: 576px) {
      $class-prefix: col-ipad-;
      @for $n from 1 through 24 {
        &.#{$class-prefix}#{$n} {
          width: ($n / 24) * 100%;
        }
      }
      $class-prefix: offset-ipad-;
      @for $n from 1 through 24 {
        &.#{$class-prefix}#{$n} {
          margin-left: ($n / 24) * 100%;
        }
      }
    }

    // md
    @media (min-width: 768px){
      $class-prefix: col-narrow-pc-;
      @for $n from 1 through 24 {
        &.#{$class-prefix}#{$n} {
          width: ($n / 24) * 100%;
        }
      }
      $class-prefix: offset-narrow-pc-;
      @for $n from 1 through 24 {
        &.#{$class-prefix}#{$n} {
          margin-left: ($n / 24) * 100%;
        }
      }
    }

    // lg
    @media (min-width: 992px) {
      $class-prefix: col-pc-;
      @for $n from 1 through 24 {
        &.#{$class-prefix}#{$n} {
          width: ($n / 24) * 100%;
        }
      }
      $class-prefix: offset-pc-;
      @for $n from 1 through 24 {
        &.#{$class-prefix}#{$n} {
          margin-left: ($n / 24) * 100%;
        }
      }
    }

    // xl
    @media (min-width: 1200px) {
      $class-prefix: col-wide-pc-;
      @for $n from 1 through 24 {
        &.#{$class-prefix}#{$n} {
          width: ($n / 24) * 100%;
        }
      }
      $class-prefix: offset-wide-pc-;
      @for $n from 1 through 24 {
        &.#{$class-prefix}#{$n} {
          margin-left: ($n / 24) * 100%;
        }
      }
    }

  }
```

### ③git 时光穿梭？

> - `HEAD`指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令`git reset --hard commit_id`。
> - 穿梭前，用`git log`可以查看提交历史，以便确定要回退到哪个版本。
> - 要重返未来，用`git reflog`查看命令历史，以便确定要回到未来的哪个版本。

由于我是看完一个视频，就把这个视频所涉及到的提交都给完成了。

然而当我回顾这个视频的时候，我需要知道当初的代码是怎样的，于是，我需要对提交历史的版本进行时光穿梭：

1. 查看提交的历史版本 ： `git log`，alias为 `glog`。

2. 确定要回到过去的历史版本：

   ![1563183974006](img/07/1563183974006.png)

3. copy好这个版本你所需要的代码。
4. 然后 `git checkout master`即可回到原先的最新版本

> 你可以git branch 一下，并没有增加新的分支。

这种姿势比较粗暴简单，另外一种姿势这是直接这样：

![1563184478568](img/07/1563184478568.png)

回到之前的最新版本，需要知道它的id。

![1563184590540](img/07/1563184590540.png)

**➹：**[版本回退 - 廖雪峰的官方网站](https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192)

**➹：**[git 切换到之前的版本上 - zhyh1435589631的专栏 - CSDN博客](https://blog.csdn.net/zhyh1435589631/article/details/51970944)

**➹：**[常用 Git 命令清单 - 阮一峰的网络日志](http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html)





