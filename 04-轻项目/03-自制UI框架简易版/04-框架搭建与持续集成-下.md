---
typora-copy-images-to: img\04\03
---

# 框架搭建 & 持续集成（下）

## ★课程简介

### ◇注意：Windows 用户运行 `npm run dev-test` 时会出现 BUG

1. 从这节课开始，你需要用 `npx parcel index.html --no-cache` 来开启项目（可以把这个命令写到 `npm start` 里）
2. Windows 用户运行 `npm run dev-test`时会出现 BUG，貌似是因为 Windows 不支持 `&&` 符号，解决办法是：将 dev-test 对应的命令  `parcel watch test/* --no-cache & karma start`分别运行，运行方式如下：
   1. 新开一个 Git Bash 窗口运行 `npx parcel watch test/* --no-cache`
   2. 再开一个 Git Bash 窗口运行 `npx karma start`

### ◇npm publish 遇到 403 怎么办？

![403](img/04/03/2018-8-23-0-11-31.png)

首先看log里面有没有 taobao 字样（截图中有）

* 如果有这说明你没有切换到 npm 原始源，那么你只需要用 `npm config delete registry` 删除淘宝源，然后再 publish。
    publish 成功之后再切换回淘宝源 `npm config set registry https://registry.npm.taobao.org`
    如果嫌切换不方便，可以安装 [nrm](https://github.com/Pana/nrm) 来快速切换源。
* 如果没有 taobao 字样，继续往下看

![403](img/04/03/2018-8-23-0-23-48.png)

看看 log 里面有没有「spam detection」字样

* 如果有
    这说明你的 package name 看起来像是 spam（垃圾邮件），你需要换一个更正常的名字。比如 `china-number-one-haha`
* 如果没有
    可能是你的 pacakge name 已经被人注册了，换个 name 试试

### ◇目录

1. 自动化测试
2. 持续集成
3. 重写所有代码
4. 发布 npm 包
5. 完善 README

## ★警告：npm link 在 Windows 上会抽风

如果你 npm link 之后项目报错，你就不要再用 npm link 了

你只需要每次改完代码后 npm publish ，然后再在另一个地方 npm install [xxx@0.0.x](mailto:xxx@0.0.x) 即可。

## ★自动化测试

### ◇使用 Karma + Mocha做单元测试

1. Karma（`[ˈkɑrmə]` 卡玛）是一个测试运行器，它可以呼起浏览器，加载测试脚本，然后运行测试用例
2. Mocha（`[ˈmoʊkə]` 摩卡）是一个单元测试框架/库，它可以用来写测试用例
3. Sinon（西农）是一个 spy / stub / mock 库，用以辅助测试（使用后才能理解）

### ◇<a id="yi">步骤</a>

1. 安装各种工具
   `npm i -D karma karma-chrome-launcher karma-mocha karma-sinon-chai mocha sinon sinon-chai karma-chai karma-chai-spies`

2. 创建 karma 配置

   ```js
   // 新建 karma.conf.js，内容如下
   module.exports = function (config) {
     config.set({
   
       // base path that will be used to resolve all patterns (eg. files, exclude)
       basePath: '',
       // frameworks to use
       // available frameworks: https://npmjs.org/browse/keyword/karma-adapter
       frameworks: ['mocha', 'sinon-chai'],
       client: {
         chai: {
           includeStack: true
         }
       },
   
   
       // list of files / patterns to load in the browser
       files: [
         'dist/**/*.test.js',
         'dist/**/*.test.css'
       ],
   
   
       // list of files / patterns to exclude
       exclude: [],
   
   
       // preprocess matching files before serving them to the browser
       // available preprocessors: https://npmjs.org/browse/keyword/karma-preprocessor
       preprocessors: {},
   
   
       // test results reporter to use
       // possible values: 'dots', 'progress'
       // available reporters: https://npmjs.org/browse/keyword/karma-reporter
       reporters: ['progress'],
   
   
       // web server port
       port: 9876,
   
   
       // enable / disable colors in the output (reporters and logs)
       colors: true,
   
   
       // level of logging
       // possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG
       logLevel: config.LOG_INFO,
   
   
       // enable / disable watching file and executing tests whenever any file changes
       autoWatch: true,
   
   
       // start these browsers
       // available browser launchers: https://npmjs.org/browse/keyword/karma-launcher
       browsers: ['ChromeHeadless'],
   
   
       // Continuous Integration mode
       // if true, Karma captures browsers, runs the tests and exits
       singleRun: false,
   
       // Concurrency level
       // how many browser should be started simultaneous
       concurrency: Infinity
     })
   }
   ```

3. 创建 test/button.test.js 文件

   ```js
   const expect = chai.expect;
   import Vue from 'vue'
   import Button from '../src/button'
   
   Vue.config.productionTip = false
   Vue.config.devtools = false
   
   describe('Button', () => {
     it('存在.', () => {
       expect(Button).to.be.ok
     })
     it('可以设置icon.', () => {
       const Constructor = Vue.extend(Button)
       const vm = new Constructor({
         propsData: {
           icon: 'settings'
         }
       }).$mount()
       const useElement = vm.$el.querySelector('use')
       expect(useElement.getAttribute('xlink:href')).to.equal('#i-settings')
       vm.$destroy()
     })
     it('可以设置loading.', () => {
       const Constructor = Vue.extend(Button)
       const vm = new Constructor({
         propsData: {
           icon: 'settings',
           loading: true
         }
       }).$mount()
       const useElements = vm.$el.querySelectorAll('use')
       expect(useElements.length).to.equal(1)
       expect(useElements[0].getAttribute('xlink:href')).to.equal('#i-loading')
       vm.$destroy()
     })
     it('icon 默认的 order 是 1', () => {
       const div = document.createElement('div')
       document.body.appendChild(div)
       const Constructor = Vue.extend(Button)
       const vm = new Constructor({
         propsData: {
           icon: 'settings',
         }
       }).$mount(div)
       const icon = vm.$el.querySelector('svg')
       expect(getComputedStyle(icon).order).to.eq('1')
       vm.$el.remove()
       vm.$destroy()
     })
     it('设置 iconPosition 可以改变 order', () => {
       const div = document.createElement('div')
       document.body.appendChild(div)
       const Constructor = Vue.extend(Button)
       const vm = new Constructor({
         propsData: {
           icon: 'settings',
           iconPosition: 'right'
         }
       }).$mount(div)
       const icon = vm.$el.querySelector('svg')
       expect(getComputedStyle(icon).order).to.eq('2')
       vm.$el.remove()
       vm.$destroy()
     })
     it('点击 button 触发 click 事件', () => {
       const Constructor = Vue.extend(Button)
       const vm = new Constructor({
         propsData: {
           icon: 'settings',
         }
       }).$mount()
   
       const callback = sinon.fake();
       vm.$on('click', callback)
       vm.$el.click()
       expect(callback).to.have.been.called
   
     })
   })
   ```

4. 创建测试脚本

   在 package.json 里面找到 scripts 并改写 scripts

   ```json
   "scripts": {
        "dev-test": "parcel watch test/* --no-cache & karma start",
        "test": "parcel build test/* --no-minify && karma start --single-run"
    },
   ```

5. 运行测试脚本

   1. 要么使用 `npm run test` 一次性运行

      ![æªå¾](img/04/03/2018-6-30-18-25-41.png)

   2. 要么使用 `npm run dev-test` 进行 watch 运行

      ![1558353697130](img/04/03/1558353697130.png)

### ◇成果

如此一来，你开发的时候新开一个命令行窗口运行 `npm run dev-test` 就可以实时查看测试结果。
如果你只想看一次结果，就只用运行 `npm run test`

## ★发布 npm 包

### ◇确保你的代码测试通过了

`npm run test` 全部是绿色（原谅色）才行。

### ◇上传代码到 npmjs.org

1. 更新 package.json
   1. 在 package.json 里将版本号改为 0.0.1，等我们做完了再改成 1.0.0
   2. 创建 index.js，在 index.js 里将你想要导出的内容全部导出
2. 去 <https://www.npmjs.com/> 注册一个账户
3. 确认一下邮箱（必须）
4. 在 gulu 项目根目录运行 npm adduser
   - 如果错误提示里面含有 [https://registry.npm.taobao.org](https://registry.npm.taobao.org/) 则说明你的 npm 源目前为淘宝源，需要更换为 npm 官方源
5. 运行 npm publish

### ◇使用自己的包

1. 预测其他使用你的包的人会怎么使用
   - 使用 vue-cli
   - 使用 webpack
   - 使用 parcel
2. 分别使用这些方式来使用自己的包（我们只以 vue-cli 为例）
   1. 使用过程中我们发现报错说 import 语法有问题，那时因为 node 目前确实不支持 import，我们需要用 babel 转译 import
      1. 你可以要求使用者自己用 babel 来转译
      2. 你也可以转义好了再给他用
         - `npx parcel build index.js --no-minify` （本来不应该加 --no-minify 的，奈何不加会有 bug，HTML 压缩把 slot 标签全删了）
         - 将 package.json 的 main 改为 dist/index.js
3. 使用 npm link 或者 yarn link 来加速调试
   1. 你每次修改源码之后，有两条路让别人得到最新效果
      1. 更新 package.json 里的 version，然后 npm publish。别人通过 npm update xxx 来更新。
      2. 如果你只是为了本地调试，可以在项目目录使用 npm link，然后在使用之处运行 npm link xxx，就是最新了

## ★持续集成

我们一开始要自己打开 Chrome 测试我们的代码
后来使用 Karma 可以做到一行命令测试我们的代码

想一想，还能不能再自动化一点。

这就是持续集成

---

## ★这次课讲什么？

> 这次课让上节课的代码变得非常的完善

这次课讲什么？（很多都咩有接触过）

1. 自动化测试
2. 持续集成
3. 重写所有代码（这一部分讲真很不喜欢，但是不得不这样做）
4. 发布 npm 包（让别人可以使用我们的轮子，只要安装了这个包就可以使用20多个轮子，目前只做了一个button轮子）
5. 完善 README

如果你的前端生涯未经历过以上过程，那么这次课是非常重要的！

之后的课，大都重复前4节的课！因为都是重复造轮子哈！

## ★使用Karma做自动化测试

### ◇为什么需要自动化测试

> 本来芳芳的自动化测试用的是 puppeteer（这个安装下载特别大），奈何GG了。
>
> **➹：**[自动化测试 · FrankFang/frank-test-1@05084aa](https://github.com/FrankFang/frank-test-1/commit/05084aa2afd48681d909f5ec9060cfee28e64d36?diff=unified)
>
> **➹：**[大前端神器安利之 Puppeteer - 前端 - 掘金](https://juejin.im/entry/5a3aa0e86fb9a045076fd385)

目前的单元测试做法：通过打开浏览器，刷新页面就测完了。

简单说一下我们做了哪些几个测试：

1. 测试按钮含有icon：生成一个vm，把vm挂载到内存里……
2. 测试假如loading存在，icon是否还会显示？
3. ……

可见单元测试使得我们可以通过代码来测试我们所写的代码是不是对的！

我们知道，所写的5个测试，每次都得打开浏览器刷新页面才能看到测试结果。

自动刷新，我们借助parcel可以做到，可是自动打开浏览器可以做到吗？

### ◇如何让电脑自动打开浏览器？自动点刷新呢？全都自动化呢？

> 只需要输入一行命令，就可以知道我们的代码到底有没有问题！
>
> 接下来，我们要做什么呢？
>
> 把我们打开浏览器，然后加载JavaScript，然后看出没出错的这个过程，完全自动化哈！

#### 做法

> 参考 [①](#yi)

1. 安装各种工具：

   1. Karma，可以运行我们的测试，如它可以自动呼起浏览器，自动加载测试脚本，自动运行我们的测试用例，简而言之，它就是一个测试运行器
   2. Mocha，咖啡的名字，摩卡咖啡，可见JavaScript老是跟咖啡过不去！它是一个单元测试库，当然也有人认为它是个框架，它可以用来干嘛了？可以用来写测试用例！
   3. Sinon，是一个 spy / stub / mock 库，用以辅助测试（使用后才能理解）

   > 或许以上3个工具你都不懂，但是这没有关系呀！因为它们都是工具呀！既然它们是工具，那么只需要照着芳芳的做法过程做一遍，那么你就学会了，无须知道中间的原因是什么！
   >
   > 请设置好淘宝源！如果需要下载很久，那么肯定是在package.json里边添加了什么东西：
   >
   > ![1558595757250](img/04/03/1558595757250.png)
   >
   > 也就是npm会自动的去读依赖安装，即便你没有显示说安装它们，换言之，先把安装版本写到 `devDependencies`里边去，然后去安装咩有安装过的！

   安装结果：

   ![1558595970932](img/04/03/1558595970932.png)

2. 创建karma配置（可以简单认为karma就是一个可以帮我们打开浏览器的的工具）

   在root目录里边，创建一个 `karma.conf.js`文件，文件名必须一样，不然会报错哈！

3. ![1558596383867](img/04/03/1558596383867.png)

   创建test/button.test.js

4. 创建运行测试用例的脚本，之后会解释这个脚本为何意，先跑通这个过程再说！这个脚本的步骤过程还挺复杂的，如果直接讲是听不懂的，还是得先看到效果之后才去讲，才比较好！

   ![1558604052383](img/04/03/1558604052383.png)

5. 运行测试脚本 `npm run test`

#### 解释以上过程做了什么？

> 即 `npm run test`做了什么

1. 把js打包一下
2. 打开chrome
3. 在chrome里边输入网址，运行网页
4. 测试用例试运行完毕后，就自动关闭那个chrome浏览器
5. 然后把浏览器的输出显示到终端里边

以上就是这一句话所做的事情了。

然而报错了：

![1558604456000](img/04/03/1558604456000.png)

这个报错是芳芳故意而为之的！根据错误信息，我们来来看看button这个组件是怎么写的：

![1558604537785](img/04/03/1558604537785.png)

我们直接用了`g-icon`这个自定义组件，而使用这个自定义组件有两种方式：

1. 全局注册

   ![1558604754011](img/04/03/1558604754011.png)

   > webstorm使用技巧：如果单词拼写错了，会搞个绿色波浪线；如果import过来的变量没有被使用，那么 `import Icon from ‘./icon’`是咩有被高亮的，呈现为灰色

2. 局部注册

做了上边那个1步骤之后，请清掉缓存，不然依旧会报错，为什么要清呢？没有理由，经验之谈，做多了，就会这样：
![1558605073206](img/04/03/1558605073206.png)

再次说说这个清掉缓存的方案是如何产生的：

1. 代码没有错，就是莫名出现这样的错误：

   ![1558605280760](img/04/03/1558605280760.png)

2. 那么是哪里出错了呢？搜索结果，然后没有找到答案。

3. 之后大概花了10多分钟，用了7、8种方法，发现把上次打包的东西给删掉，然后重新打包就好了

这就是为什么芳芳要输入 `rm -rf .cache dist`的原因所在了！这是很多书都不会讲的内容！

> 所以很多时候，你写代码遇到了问题，不是因为你代码写不好，是因为你尝试得不够多！

知道结果很简单，但实际上却不是这样的！

回顾一下，我们是如何解决bug的？

在button.vue里边，把icon组件注册为全局组件即可！

然而在button.vue里边注册全局是不太好的行为，虽然这可以注册！

于是。我们就使用另一种方法，来解决这个问题了，即局部注册icon组件！

![1558605729390](img/04/03/1558605729390.png)

告诉button，你里边的g-icon对应是我写的icon.vue这个组件

再次运行 `npm run test`

然而还是报错，于是又运行 `rm -rf .cache dist`之后，再`npm run test`

结果跑通了

难道我们每次修改了一下button.vue的内容，都得 `rm -rf .cache dist`一下吗？这未免也太麻烦了吧！

话说，能不能不删啊！

可以啊，修改一下脚本即可（追加`--no-cache`）：

![1558606025133](img/04/03/1558606025133.png)

以上，我们就跑通了项目了！

我的测试结果：

![1558606977086](img/04/03/1558606977086.png)

### ◇回顾自动化测试，做了哪些事情才能到达我们想要的效果

现在，我们就可以看到一个自动化测试的结果了！而这个时候，我们再来解释自动化测试的过程就很好理解了。

我们运行 `npm run test`实际上会调用什么呢？

①看我们在package.json里边写的test命令，毕竟run了一下test，即运行一下test命令哈！

②那么test做了什么呢？

1. 首先运行 `parcel build test/* --no-cache --no-minify `

   `test/*`表示test目录下所有的一级文件

   然后后边加两个参数表示，不要缓存，不要minify。不要缓存好理解，而不要minify呢？也好理解，因为如果不加就会出错，总之这两个参数都是试出来的！而且这两个参数，芳芳并没有看到哪个文档说必须要加这两个参数的，总之，你不叫就会出bug。可见，现在的parcel不是那么完善，后面我们会改成其它的构建工具！

   所以这句话的整体意思就是，**让parcel去打包test目录下的所有一级文件，而且不要缓存，不要最小化（不要压缩）**

   如果你单独在终端运行这个命令，请加上npx，因为我们并咩有全局安装parcel！

   > 终端使用技巧，由于需要单独运行该命令，所以需要添加npx，而这个npx处于开头，可以ctrl+a让光标定位到开头，ctrl+e定位到结尾，注意这是windows下的做法！

   目前的目录结构：

   ![1558608305199](img/04/03/1558608305199.png)

   单独运行这个命令的结果：

   ![1558608584004](img/04/03/1558608584004.png)

   话又说回来，这打包做了啥？或者说为啥我们需要用parcel去打包呢？因为我们用了一些语法，比如说 `import Vue from 'vue'`这一句浏览器是不认识的，至少目前浏览器是不认识的，所以当浏览器执行到这儿：

   ![1558610570728](img/04/03/1558610570728.png)

   所以，打包会把vue的源代码给拷进来！

   然后把vue做成一个变量暴露出来！

   总之，这句代码会被parcel打包成把vue的源代码拷过来这么一个事情！同理button也是如此！

   所以为啥要打包呢？因为这些语句浏览器以及node都不认识呀！所以需要把它们翻译成浏览器所认识的才行呀！

   查看打包效果：

   没有打包：79行代码

   打包之后：10191行代码，为什么多了这么多行代码呢？因为大部分都是vue的源码啊！总之打包出来的代码都是parcel自己翻译的，无须去理解这里边的代码是啥意思，毕竟这没必要呀！总之打包这个过程就是把浏览器不懂的变成懂的！

2.  `karma start --single-run`

   来到这一句了！这表示karma启动，然后只运行一次哈！

   那么karma该如何启动呢？

   > 再次回顾一下我们在做什么，在做自动化测试哦！
   >
   > 那么怎么做的呢？只要运行 `npm run test`即可
   >
   > 然后 分析 `npm run test`做了什么！
   >
   > 1. 把test目录下一级文件打包
   > 2. 运行karma

   karma如何运行呢？这就需要在另外一个文件里去描述了，这个文件叫做karma.conf.js ，表示karma配置js

   查看该配置文件中一些特别配置：

   ![1558618750312](img/04/03/1558618750312.png)

   > `**`表示可以跨级

   需要注意的是 ，虽然我们的单元测试代码 `button.test.js`没有css，但是我们还是得写上 `'dist/**/*.test.css'`，如果你不写的话，那么运行 `parcel build test/* --no-cache --no-minify && karma start --single-run`是会报错的，报错如下：

   ![1558619028489](img/04/03/1558619028489.png)

   由于没有加载默认的CSS，那么涉及CSS测试的单元测试，那就GG了。

   可是这个CSS是来自哪儿的呢？

   ![1558619279744](img/04/03/1558619279744.png)

   可见，parcel在打包的时候，会把该文件button.test.js里边的js和css分开！

   这样一来就方便我们去引用了！

   所以说parcel并咩有把整个button.vue文件打包成js哈！

   所以如果你不加 `'dist/**/*.test.css'`上这句话的话，那么所有跟样式相关的测试用例，全部都会挂！

   接下来：

   ![1558619576179](img/04/03/1558619576179.png)

   注意，选择哪个浏览器打开，都是需要装插件的：

   ![1558619763530](img/04/03/1558619763530.png)

   不是说你想用啥浏览器打开就用啥打开！我们在这里默认打开的是chrome

   总之知道该配置文件的两个即可！

### ◇小结

1. 运行 `npm run test`

   1. 打包
   2. 启动karma
   3. karma去启动chrome
   4. 运行完测试用例就关闭chrome
   5. 退出chrome

   以上就是我们目前的自动化过程了！

2. 我们看了哪些文件：

   1. package.json：

      ```json
      "test": "parcel build test/* --no-cache --no-minify && karma start --single-run"
      ```

   2. karma.conf.js：

      ```js
      files: [
          'dist/**/*.test.js',
          'dist/**/*.test.css'
      ],
      browsers: ['ChromeHeadless'],
      ```

3. 接下来看我们的测试用例 `button.test.js` 该怎么写，这个问题很重要！

---

## ★使用Mocha&Chai做单元测试

> 接下来看看我们的测试用例 `button.test.js` 是怎么写的！

### ◇之前的单元测试代码

在此之前，先来看看引入Mocha&Chai之前，我们的测试用例是怎么写的

写了6个测试用例，每个测试用例都是个block：

![1558624540834](img/04/03/1558624540834.png)

咩有必要说如果不写 `{}`，那么变量名就会冲突了，那就就会报错，而是直接说作用域隔离就好了！

总之我们写单元测试，一定要做的就是：

1. 作用域隔离
2. 断言

而其它的则可有可无，总之这两个一定要有，只是它们看起来比较简陋，只是使用了一个 大括号`{}`就把测试用例给隔离了和 使用了chai库的expect方法就搞了断言

之后，我们还引入了一个叫间谍的库——spy

然后用spy也进行了一次断言！

### ◇高级写法的单元测试代码

而现在的高级写法也是一样的！

1. 隔绝每个单元测试，我们用的是it，每个it就是一个新的测试用例！而隔绝的方法是通过函数来隔绝！

   ![1558628023463](img/04/03/1558628023463.png)

   箭头函数里边的代码基本上跟之前的测试代码一样！

   对了，我们之前的测试代码也可以取名字，可以用注释，或者没有意义的字符串，就像这样：

   ![1558659450085](img/04/03/1558659450085.png)

   总之，相较于旧姿势，新姿势的代码思路几乎咩有区别，而且代码几乎差不多，只是以前用 block`{}`，而现在则变成了`it`

### ◇describe和it

BDD，行为驱动测试，我们的高级写法测试代码或许是BDD，又或许是TDD，但是这不重要啊！形式上好看，能测试代码不就好了吗！

我们描述（describe）了button的一系列行为、属性，如它（it）能做什么，它有什么……

![1558662221104](img/04/03/1558662221104.png)

### ◇详解最后一个测试用例的fake函数

关于最后一个测试用例：

![1558662099219](img/04/03/1558662099219.png)

结果：

![1558662048975](img/04/03/1558662048975.png)

可见，有了单元测试，你看那英文的报错信息，就很容易就能知道我们的代码哪里写错了！

为什么需要fake？

假如你这样写的话：

![1558662498377](img/04/03/1558662498377.png)

为了测试的严谨性，你不能再callback里写出上这样的代码：

```js
expect(1).to.eq(1)
```

因为这个断言是不可控的，换言之，我写个错误的断言也是可以的，但实际上我们触发的函数确实被调用了啊！我们自己所写的代码咩有问题，但是测试用例就是出错了！所以说我们必须要用个mock函数——它不是一个真正触发被执行的函数，但是它知道要被触发的函数式否被调用了！

总之，用到mock函数的原因是因为我们想我们的断言是可控的、严谨的！

我们要检测一个函数是否被调用了，用原生JavaScript写是很难的，我们借助了sinon这个库是很容易就可以做到的！而fake这个api的原理就像是callback被调用之后，会有个标志位存储callback被调用的标志，配合chai这个断言库，就很容易做到检测一个函数式否被调用了！

总之 `sinon.fake()`这个假函数有个特点就是，知道自己有没有被调用，被调用时传了什么参……

假如你的expect这样写的话：

![1558663681756](img/04/03/1558663681756.png)

> 我们安装了哪些库？
>
> ![1558663815583](img/04/03/1558663815583.png)

结果：

![1558663592921](img/04/03/1558663592921.png)

总之，没有使用这些mock函数库的话，那么chai.expect是不知道所传过来的普通callback `functon(){}` 是否被调用的，毕竟chai.expect也是代码啊，它可不会像我们肉眼那样可以查看控制台有没有log输出！对于它而言，就是一个函数表达式参数而已啊！除非你是个fake()，是一个假的函数，让我来大概猜测这个fake()的执行原理：

![1558664647237](img/04/03/1558664647237.png)

> 突然感觉写测试用例，真得很容易理解我们当初所写的代码到底是在做什么，如为什么要自定义一个icon属性、一个loading属性、一个iconPosition属性、还有为啥需要为button元素上添加@click方法
>
> 这一切的答案都能在测试用例中找到，因为我们这样做了，写了这样的代码:
>
> ![1558664988361](img/04/03/1558664988361.png)
>
> 而当用户写了这样的代码：
>
> ```vue
> <g-button icon="settings" icon-position="right" :loading="loading3" @click="loading3 = !loading3">按钮</g-button>
> ```
>
> 我们就能预期用户在页面上得到了什么样的输出！
>
> 即用户的代码是输入
>
> 组件库的开发者是写函数的人
>
> 而单元测试是判断开发者所写的这个函数是否如期望般的运行，只要拿到函数的输出，就能99%（看你的测试用例写得好不好）预测到页面的最终呈现了！
>
> 总而言之，单元测试就像是你写代码时的思路一样！
>
> 再看BDD：行为驱动开发，你所有的开发是因为你要满足用户的某个行为
>
> 用户写了这样那样的组件标签，并写上了这样那样的自定义属性，并添加了这样那样的@click行为等
>
> 然后我们根据这样的行为，就用代码实现这样的行为会有怎样的预期效果！
>
> 讲真，我还是不理解BDD和TDD的区别！
>
> 难道TDD指的是用户所写代码层次上的描述？而BDD则是代码层面上的思路描述？即BDD这种测试用例在描述上是非常通俗易懂的！
>
> **➹：**[TDD与BDD的差别 - Lucas](http://ilucas.me/2016/03/07/difference-between-tdd-and-bdd/)
>
> **➹：**[一文告诉你ATDD,TDD,BDD的区别 - 简书](https://www.jianshu.com/p/80929aa1d20c)

话又说回来，fake函数相当于我们之前spy，但是写法上更加简洁：

![1558666394557](img/04/03/1558666394557.png)

### ◇回顾

回顾三个文件：

1. 在package.json里边写上test
2. 在karma.conf.js里边写上要载入的css和js，以及指定浏览器
3. 在button.test.js里边，用BDD写单元测试，用it隔开每个测试用例，而其中的测试用例内容，用断言来写，而这断言能预测我们的描述行为即可！

### ◇断言该如何写？

> 为啥可以想 `.to.equal('#i-settings')`、`.to.eq('1')`、`.to.have.been.called`这样写？
>
> 这看起来像是神来之笔呀！无法预料呀！

我怎么知道我该如何写测试用例？

#### 两步走

1. 记住一个最万能的语句：

   ![1558668166206](img/04/03/1558668166206.png)

2. 高级点的语句：

   回顾我们选择Expert风格的断言：

   ![1558668311344](img/04/03/1558668311344.png)

   查看BDD风格的expect：

   **➹：**[Expect / Should - Chai](https://www.chaijs.com/api/bdd/)

#### 解析BDD风格的expert API

**①无须理会虚词**

![1558668570405](img/04/03/1558668570405.png)

它们的存在就是为了让我们的断言语法变得更好看而已！

总之它们都是虚词，你爱写不写都行：

```js
expect(Button).to.be.ok
//这样写也行
expect(Button).be.ok
```

**②not不是一个虚词**

它表示相反的！

![1558669238390](img/04/03/1558669238390.png)

结果：

![1558669411737](img/04/03/1558669411737.png)

> 每次修改了断言，都得`npm run test`吗？然后重新编译呢？能不能快一点呢？

接下来，不会一个个讲了，直接讲最难的

**③deep**

深相等

```js
expert([1,2]).to.eq([1,2]) //断言错误，显然这是两个不同对象，毕竟地址不同，如 [1,2]==[1,2]也是错的
expert([1,2]).to.deep.eq([1,2])//断言正确，深入进去看呀，元素一致即可
```

总之，不用deep就是比较地址是否一致，用了deep就是比较里面的东西是不是相等！

关于深拷贝和浅拷贝：[js 深拷贝 vs 浅拷贝 - 掘金](https://juejin.im/post/59ac1c4ef265da248e75892b)

**④own**

这个对象是拥有的xxx属性是否是自己的？还是继承的

**⑤`.a(type[, msg])`**

期待一个值是类型的，虚词用a或者an都行

> 这种只看意思，不看语法的表达真好！下次翻译的时候，只需知意即可！无须理会为啥要这样写！

⑥ `.NaN`

为啥有这样的测试用例呢？

根据自己的基础知识可知，NaN是不等于NaN的！

```js
expert(NaN).to.eq(NaN) //测试失败
```

为了以防这种情况出现，才有了这种情况：

```js
expect(NaN).to.be.NaN; //测试通过
```

这就是我们为啥不得不为NaN单独写的断言缘故了！毕竟期望的值是NaN

⑦ `.exist`

```js
expect(Button).to.be.ok
//下面这种姿势更好,直接明白「断言这个Button是存在的」
expect(Button).to.exist
```

之后会遇到奇奇怪怪的断言，所以剩下的API之后说！

记下来我们来讲一下优化！

就是说我们每次改测试用例代码，都得运行一下 `npm run test`

难道你就不能我一改你就自动运行 `npm run test`呢？

不要我等好几秒呢？

那么问题来了「如何做到每次改代码，不用重新build？」

---

## ★使用TravisCI做持续集成

















## ★总结

- 「为什么」就像是一根线一样，串联起了那些游离的知识点。为什么上节课做了单元测试之后，还要做自动化的单元测试。因为「懒」啊！我们不想打开浏览器，刷新页面，然后运行我们的单元测试。我们只想在终端敲下一个命令就能把这些活儿给做了。

## ★Q&A

### ①describe和it属于哪个库？

属于Mocha这个库！

你可以看到我们button.test.js这个文件，这个库我们并没有引入，因为它是自动引入的！

总之BDD行为驱动测试是由Mocha这个库搞的

而expert断言则是由chai这个库搞的！



